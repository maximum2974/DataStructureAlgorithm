# 1、数据结构诸论

## 1.1 基本概念和术语

数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。

==程序设计 = 数据结构 + 算法==

### 1.1.1 数据

数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整形、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。

我们这里所说的数据，其实就是符号，而且这些符号必须具备两个前提：

+ 可以输入到计算机中
+ 能被计算机程序处理

### 1.1.2 数据元素

数据元素：是组成数据、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。

### 1.1.3 数据项

数据项：一个数据元素可以有若干个数据项组成。

数据项是数据不可分割的最小单位。

### 1.1.4 数据对象

数据对象：是性质相同的数据元素的集合，是数据的子集。

既然数据对象是数据的子集，在实际应用中，处理的数据元素通常具有相同的性质，在不产生混淆的情况下，我们都将数据对象简称为数据。

### 1.1.5 数据结构

不同数据元素之间不是独立的，而是存在特定的关系，我们将这些关系称之为结构。

==数据结构：是相互之间存在一种或多种特定关系的数据元素的集合，==

## 1.2 逻辑结构与物理结构

### 1.2.1 逻辑结构

逻辑结构：是指数据对象中数据元素之间的相互关系。

1. 集合结构

集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。

2. 线性结构

线性结构：线性结构中的数据元素之间是一对一的关系。

3. 树形结构

树形结构：树形结构中的数据元素之间存在一种一对多的层次关系。

4. 图形结构

图形结构：图形结构的数据元素是多对多的关系。

我们在示意图表示数据的逻辑结构时，要注意两点：

+ 将每一个数据元素看成一个结点，用圆圈表示。
+ 元素之间的逻辑关系用结点之间的连线表示，如果这个关系是有方向的，那么用带箭头的连线表示。

### 1.2.2 物理结构

==物理结构：是指数据的逻辑结构在计算机中的存储形式==

数据的存储结构应正确反应数据元素之间的逻辑关系，如何存储数据元素之间的逻辑关系，是实现物理结构的重点和难点。

数据元素的存储结构形式有两种：顺序存储和链式存储。

1. 顺序存储结构

顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。

2. 链式存储结构

链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。

数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关数据元素的位置。

链式存储就灵活多了，数据存在哪里不重要，只要有一个指针存放了相应的地址就能找到它了。

逻辑结构是面向问题的，而物理结构是面向计算机的，其基本的目标就是将数据及其逻辑关系存储到计算机的内存中。

## 1.3 数据类型

==数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称==

### 1.3.1 数据类型的定义

数据类型是按照值的不同进行划分的。在高级语言中，每个变量、常量和表达式都有各自的取值范围。类型就是用来说明变量或表达式的取值范围和所能进行的操作。

在C语言中，按照取值的不同，数据类型可以分为两类：

（1）原子类型：是不可以再分解的基本类型，包括整型、实型、字符型等。

（2）结构类型：由若干个类型组合而成，是可以再分解的。例如，整形数组是由若干个整型数据组成的。

无论什么计算机、什么计算机语言，大都会面临着如整数运算、实数运算、字符运算等操作，我们可以考虑把它们都抽象出来。

==抽象是指抽取的事物具有的普遍性的本质。==它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。

### 1.3.2 抽象数据类型

==抽象数据类型（ Abstract Data Type， ADT）：一个数学模型及定义在该模型上的一组操作。==抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。

==抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。==抽象数据类型把实际生活中的问题分解为多个规模小且容易处理的问题，然后建立一个计算机能处理的数据模型，并把每个功能模块的实现细节作为一个独立的单元，从而使具体实现过程隐藏起来。

数据结构是相互之间存在一种或多种特定关系的数据元素的集合。

（1）逻辑结构：集合结构、线性结构、树形结构、图形结构

（2）物理结构：顺序存储结构、链式存储结构

# 2、算法

在数据结构的课程中，就算谈到算法，也是为了帮助理解好数据结构，并不会详细谈及算法的方方面面，

## 2.1 两种算法的比较

写一个求1+2+3·········+100结果的程序，大多数人会马上写出下面的C语言代码

~~~html
#include<iostream>
using namespace std;

int main()
{
	int i,sum = 0,n = 100;
	for(int i = 0; i <= n; i++)
	{
		sum = sum + i; 
	}
	cout << sum << endl;
} 
~~~

但如果运用高斯算法，是不是很快就能得出结果

~~~html
#include<iostream>
using namespace std;

int main()
{
	int sum = 0,n = 100;
	sum = (1 + n) * n / 2;
	cout << sum << endl;
} 
~~~

## 2.2 算法定义

==算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。==

为了解决某个或某类问题，需要把指令表示成一定的操作序列，操作序列包括一组操作，每一个操作都完成特定的功能，这就是算法了。

## 2.3 算法的特性

算法具有五个基本的特性：输入、输出、有穷性、确定性和可行性。

### 2.3.1 输入输出

==算法具有零个或多个输入==

==算法至少有一个或多个输入==

### 2.3.2 有穷性

==有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成==

### 2.3.3 确定性

==确定性：算法的每一步骤都具有确定的含义，不会出现二义性==

算法在一定条件下，只有一条执行路径，相同的输入只能由唯一的输出结果。算法的每个步骤被精确定义而无歧义。

### 2.3.4 可行性

==可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过过执行有限次数完成。==

可行性意味着算法可以转换为程序上机运行，并得到正确的结果。

## 2.4 算法设计的要求

算法不是唯一的。也就是说，同一个问题，可以有多种解决问题的算法。

### 2.4.1 正确性

==正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性，能正确反映问题的需求，能够得到问题的正确答案。==

但是算法的“正确”通常在用法上有很大的差别，大体分为以下四个层次。

（1）算法程序没有语法错误

（2）算法程序对于合法的输入数据能够产生满足要求的输出结果

（3）算法程序对于非法的输入数据能够得出满足规格说明的结果

（4）算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果

算法的正确性在大部分情况下都不可能用程序来证明，而是用数学方法证明的。所以在一般情况下，我们把层次（3）作为一个算法是否正确的标准。

好算法还具有容易理解的特征。

### 2.4.2 可读性

==可读性：算法设计的另一目的是为了便于阅读、理解和交流。==

可读性是算法（也包括实现它的代码）好坏很重要的标志。

### 2.4.3 健壮性

==健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。==

### 2.4.4 时间效率高和存储量低

时间效率指的是算法的执行时间。对于同一个问题，如果有多个算法能够解决，执行时间短的算法效率高，执行时间长的效率低。存储量需求指的是算法在执行过程中需要的最大存储空间，主要指算法程序运行时所占用的内存或外部硬盘存储空间。

==设计算法应该尽量满足时间效率高和存储量低的需求==

## 2.5算法效率的度量方法

我们通过对算法的数据测试，利用计算机的计时功能，来计算不同算法的效率是高还是低。

### 2.5.1 事后统计方法

==事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低==

但是这种方法显然是有很大的缺陷的：

+ 必须依据算法事先编制好程序，这通常需要花费大量的时间和精力。
+ 时间的比较依赖计算机硬件和软件等环境因素，有时会掩盖算法本身的优劣。
+ 算法的测试数据设计困难，并且程序的运行时间往往还与测试数据的规模有很大关系，效率高的算法在小的测试数据面前往往得不到体现。

### 2.5.2 事前分析估算方法

==事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算。==

算法估算：

（1）算法采用的策略、方法

（2）编译产生的代码质量

（3）问题的输入规模

（4）机器执行指令的速度

第（1）条当然是算法好坏的根本，第（2）条要由软件来支持，第（4）条要看硬件性能。

==一个程序的运行时间，依赖于算法的好坏和问题的输入规模。所谓问题输入规模是指输入量的多少==

==最终，在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤==

 ## 2.6 函数的渐近增长

输入规模n在没有限制的情况下，只要超过一个数值N，这个函数就总是大于另一个函数，我们称函数是渐近增长的。

==函数的渐近增长：给定两个函数 f(n) 和 g(n) ，如果存在一个整数N，使得对于所有的n > N，f(n) 总是比 g(n) 大，那么，我们说 f(n) 的增长渐近快于 g(n)。==

注意事项：

+ 与最高次项相乘的常数并不重要
+ 最高次项的指数大的，函数随着n的增长，结果也会增长更快
+ 判断一个算法的效率时，函数中的函数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数

某个算法，随着n的增大，它会越来越优于另一算法，或者越来越差于另一算法

## 2.7 算法时间复杂度

### 2.7.1 算法时间复杂度定义

==在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模n的函数，进而分析 T(n) 随n的变坏情况并确定 T(n) 的数量级。算法的时间复杂度，也就是算法的时间量度，记作 T(n) = O(f(n)) 。它表示随问题规模n的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中 f(n) 是问题规模n的某个函数。==

这样用大写O()来体现算法时间复杂度的记法，我们称之为==大O记法==。

一般情况下，随着n的增大，T(n) 增长最慢的算法为最优算法。

### 2.7.2 推导大O阶方法

推导大O阶：

1. 用常数1取代运行时间中的所有加法常数。
2. 在修改后的运行次数函数中，只保留最高阶项。
3. 如果最高阶项存在且系数不是1，则去除与这个项相乘的系数，得到的结果就是大O阶。

### 2.7.3 常数阶

~~~html
int sum = 0,n = 100;
sum = (1 + n) * n / 2;
cout << sum << endl;
~~~

这个算法的运行次数函数是f(n)=3。根据我们推导大O阶的方法，第一步就是把常数项3改为1。在保留最高阶项时发现，它根本没有最高阶项，所以这个算法的时间复杂度为O(1)。

~~~html
int sum = 0, n = 100;
sum = (1 + n) * n / 2;
sum = (1 + n) * n / 2;
sum = (1 + n) * n / 2;
sum = (1 + n) * n / 2;
sum = (1 + n) * n / 2;
sum = (1 + n) * n / 2;
sum = (1 + n) * n / 2;
sum = (1 + n) * n / 2;
sum = (1 + n) * n / 2;
sum = (1 + n) * n / 2;
cout << sum << endl; 
~~~

事实上无论n为多少，上面的两段代码就是3次和12次执行的差异。这种与问题的大小(n的大小)无关，执行时间恒定的算法，我们称之为具有O(1)的时间复杂度，又叫常数阶。

> 注意：不管这个常数是多少，我们都记作O(1)，而不能是O(3)、O(12)等其他任何数字

对于分支结构而言，无论是真，还是假，执行的次数都是恒定的，不会随着n的变大而发生变化，所以单纯的分支结构（不包含在循环结构中），其时间复杂度也是O(1)。

### 2.7.4 线性阶

分析算法的复杂度，关键就是要分析循环结构的运行情况

~~~html
int i;
for(i = 0; i < n; i++)
{
	/*时间复杂度为O(1)的程序步骤序列*/ 
}
~~~

上面这段代码，它的循环的时间复杂度为O(n)，因为循环体中的代码需要执行n次。

### 2.7.5 对数阶

~~~html
int count = 1;
while(count < n)
{
	count = count * 2;
	/*时间复杂度为O(1)的程序步骤序列*/ 
} 
~~~

由于每次count乘以2之后，就距离n更近了一分。也就是说，有多少个2相乘后大于n，则会退出循环。由2^x^ = n得到$$x=log_2{n}$$。所以这个循环的时间复杂度为O($$logn$$)。

### 2.7.6 平方阶

~~~html
int i,j;
for(i = 0; i < n; i++)
{
	for(j = 0; j < n; j++)
	{
		/*时间复杂度为O(1)的程序步骤序列*/ 
	}
}
~~~

以上代码的内循环时间复杂度为O(n)，而对于外层循环，不过是内部这个时间复杂度为O(n)的语句，再循环n次。所以这段代码的时间复杂度为O(n^2^)。

如果外循环的循环次数改为了m，时间复杂度就变为O(m*n)。

==所以可以总结得出，循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数==。

~~~html
int i,j;
for(i = 0; i < n; i++)
{
	for(j = i; j < n; j++)
	{
		/* 时间复杂度为O(1)的程序步骤序列*/ 
	}
}
~~~

由于当i=0时，内循环执行了n次，当i=1时，执行了n-1次，······当i=n-1时，执行了1次，所以总的执行次数为：

n + (n-1) + (n-2) + ··· + 1 = $n(n+1)\over2$ = $n^2\over2$ + $n\over2$

用我们推导大O阶的方法，第一条，没有加法常数不予考虑；第二条，只保留最高阶项，因此保留$n^2$/2；第三条，去除与这个项相乘的常数，也就是去除1/2，最终这项代码的时间复杂度为O(n^2^)。

## 2.8 常见的时间复杂度

| 执行次数函数          | 阶         | 非正式用语 |
| --------------------- | ---------- | ---------- |
| 12                    | O(1)       | 常数阶     |
| 2n+3                  | O(n)       | 线性阶     |
| 3n^2^+2n+1            | O(n^2^)    | 平方阶     |
| 5$log_{2}^{n}$+20     | O($logn$)  | 对数阶     |
| 2n+3n$log_{2}^{n}$+19 | O(n$logn$) | n$logn$阶  |
| 6n^3^+2n^2^+3n+4      | O(n^3^)    | 立方阶     |
| 2^n^                  | O(2^n^)    | 指数阶     |

常用的时间复杂度所耗费的时间从小到大依次是：

O(1)<O($logn$)<O(n)<O(n$logn$)<O(n^2^)<O(n^3^)<O(2^n^)<O(n!)<O(n^n^)

## 2.9 最坏情况与平均情况

==平均运行时间是所有情况中最有意义的，因为它是期望的运行时间==

==一般在没有特殊说明的情况下，都是指最坏时间复杂度==

## 2.10 算法空间复杂度

算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。

一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的储存单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)。

# 3、线性表

## 3.1 线性表的定义

==线性表(List):零个或多个数据元素的有限序列==

首先它是一个序列。元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他每个元素都有且只有一个前驱和后继。

然后，线性表强调的是有限的。

若将线性表记为（a~1~，···，a~i-1~，a~i~，a~i+1~，···，a~n~），则表中a~i-1~领先于a~i~，a~i~领先于a~i+1~，称a~i-1~是a~i~的==直接前驱元素==，a~i+1~是a~i~的==直接后继元素==。

所以线性表元素的个数n（n$\geq$0）定义为==线性表的长度==，当n=0时，称为==空表==。

在非空表中的每个数据元素都有一个确定的位置，a~i~是第i个数据元素，称i为数据元素a~i~在线性表中的==位序==。

==在较为复杂的线性表中，一个数据元素可以由若干个数据项组成==

## 3.2 线性表的抽象数据类型

线性表的抽象数据类型定义如下：

> ADT 线性表（List）
> Data
>         线性表的数据对象集合为{a~1~，a~2~，······，a~n~}，每个元素的类型均为DataType。其中，除第一个元素a~1~外，每一个元素有且只有一个直接前驱元素，除了最后一个元素a~n~外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。
> Operation
>          InitList( *L )：初始化操作，建立一个空的线性表L。
>          ListEmpty( L )：若线性表为空，返回true，否则返回false。
>          ClearList( *L )：将线性表清空。
>          GetElem( L , i , *e)：将线性表L中的第 i 个位置元素值返回给e。
>          LocateElem( L , e)：在线性表L中查找与给定值 e 相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败。
>          ListInsert( *L , i , e)：在线性表L中的第 i 个元素位置插入新元素 e。
>          ListDelete( *L , i , *e)：删除线性表L中第 i 个位置元素，并用 e 返回其值。
>          ListLength( L )：返回线性表 L 的元素个数。
> endADT 

>当你传递一个参数给函数的时候，这个参数会不会在函数内被改动决定了使用什么参数形式。
>如果需要被改动，则需要传递指向这个参数的指针。
>如果不用被改动，可以直接传递这个参数。

代码示例如下：
~~~html
/*将所有的在线性表Lb中但不在La中的数据元素插入到La中*/
void unionL(SqList *La,SqList *Lb)
{
	int La_len,Lb_len,i;
	ELemType e;//声明与La相同的数据元素e 
	La_len = ListLength(*La);//求线性表的长度 
	Lb_len = ListLength(Lb);
	for(i = 1; i <= Lb; i++)
	{
		GetElem(Lb,i,&e);//取Lb中第i个数据元素赋给e 
		if(!LocateElem(*La,e))//La中不存在和e相同的数据元素 
		{
			ListInsert(La,++La_len,e);//插入 
		}
	}
}
~~~

## 3.3 线性表的顺序储存结构

### 3.3.1 顺序存储定义

==线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素==

### 3.3.2 顺序存储方式

用C语言（其他语言也相同）的==一维数组来实现顺序存储结构==

线性表的顺序存储的结构代码：

~~~html
#define MAXSIZE 20 //存储空间初始分配量
typedef int ElemType; //ElemType类型根据实际情况而定，这里为int
typedef struct
{
	ElemType data[MAXSIZE]; //数组，存储数据元素
	int length; //线性表当前长度 
}SqList;
~~~

发现描述顺序存储结构需要三个属性：

+ 存储空间的起始位置：数据data，它的存储位置就是存储空间的存储位置。
+ 线性表的最大存储容量：数组长度MAXSIZE。
+ 线性表的当前长度：；length。

### 3.3.3 数组长度与线性表长度的区别

数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的。

线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。

在任意时刻，线性表的长度应该小于等于数组的长度。

### 3.3.4 地址计算方法

==存储器中的每个存储单元都有自己的编号，这个编号称为地址==

假设每个数据元素占用的是c个储存单元，那么线性表中第i+1个数据元素的存储位置和第i个数据元素的存储位置满足下列关系（LOC表示获得存储位置的函数）

==LOC(a~i+1~)=LOC(a~i~)+c==

所以对于第i个数据元素a~i~的存储位置可以由a~1~推算得出：

==LOC(a~i~)=LOC(a~1~)+(i-1)*c==

通过这个公式，你可以随机算出线性表中任意位置的地址，不管它是第一个还是最后一个，都是相同的时间。那么我们对每个线性表的位置的存入或者取出数据，对于计算机来说都是相等的时间，也就是一个常数，因此用我们算法中学到的时间复杂度的概念来说，它的存储时间性能为O(1)。我们通常把具有这一特点的存储结构称为==随机存储结构==。

## 3.4 顺序存储结构的插入和删除

### 3.4.1 获得元素操作

如果我们要实现GetElem操作，即将线性表L中的第i个元素值返回，就程序而言，只要i的数值在数组下标范围内，就是把数组第i-1下标的值返回即可，代码如下：

~~~html
#define OK 1
#define ERROR 0
/*Status是函数的类型，其值是函数结果状态代码，如OK等*/
typedef int Status;
/*初始条件：顺序线性表L已存在，1<=i<=ListLength(L)*/
/*操作结果：用e返回L中第i个数据元素的值，注意i是指位置，第1个位置的数组是从0开始*/
Status GetElem(Sqlist L,int i,ElemType *e)
{
	if(L,length==0 || i<1 || i>L.length)
	{
		return ERROR;
	}
	*e = L.data[i-1]; 
	
	return OK;
} 
~~~

这里我们是把指针*e的值给修改成L.data[i-1]，这就是真正要返回的数据。

### 3.4.2 插入操作

如果要实现ListInsert(*L,i,e)，即在线性表L中的第i个位置插入新元素e，思路如下：

1. 如果插入位置不合理，抛出异常
2. 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量
3. 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置
4.  将要插入元素填入位置i处
5. 表长加1

实现代码如下：
~~~html
/*初始条件：顺序线性表L已存在，1<=i<=ListLength(L)*/
/*操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1*/
Status ListInsert(Sqlist *L,int i,ElemType e)
{
	int k;
	if(L->length==MAXSIZE)  //顺序线性表已经满
	{
		return ERROR;
	} 
	if(i < 1 || i > L->length+1)  //当i比第一位置小或者比最后一位置后一位置还要大时 
	{
		return ERROR;
	}
	if(i<=L->length)  //若插入数据位置不在表尾
	{
		for(k=L->length-1;k>=i-1;k--)  //将要插入位置后的元素向后移一位 
		{
			L->data[k+1]=L->data[k];
		} 
	}
	L->data[i-1]=e; //将新元素插入
	L->length++;
	
	return OK; 
} 
~~~

### 3.4.3 删除操作

删除算法的思路：

1. 如果删除位置不合理，抛出异常
2. 取出删除元素
3. 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置
4. 表长减1

实现代码如下：

~~~html
/*初始条件：顺序线性表L已存在，1<=i<=ListLength(L)*/
/*操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1*/
Status ListDelete(SqList *L,int i,ElemType *e)
{
	int k;
	if(L -> length == 0) //线性表为空 
	{
		return ERROR;
	}
	if(i < 1 || i > L-> length)  //删除位置不正确 
	{
		return ERROR;
	}
	*e = L -> data[i-1];
	if(i < L->length) //如果删除不是最后位置 
	{
		for(k=i;k<L->length;k++) //将删除位置后继元素前移 
		{
			L->data[k-1]=L->data[k];
		}
	}
	L->length--;
	return OK;
} 
~~~

线性表的顺序存储结构，在读数据时，不管是哪个位置，时间复杂度都是O(1)；而插入或删除时，时间复杂度都是O(n)。这就说明，它比较适合元素个数不太变化，而更多是存取数据的应用。

### 3.4.4 线性表顺序存储结构的优缺点

优点：

+ 无须为表示表中元素之间的逻辑关系而增加额外的存储空间
+ 可以快速地存取表中任意位置的元素

缺点:

+ 插入和删除操作需要移动大量元素
+ 当线性表长度变化较大时，难以确定存储空间的容量
+ 造成存储空间的“碎片”

## 3.5 线性表的链式存储结构

### 3.5.1 线性表链式存储结构的定义

线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。这就意味着，这些数据元素可以存在内存未被占用的任意位置。

对数据元素a~i~来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域称为==数据域==，把存储直接后继位置的域称为==指针域==。指针域中存储的信息称作==指针==或==链==。这两部分信息组成数据元素a~i~的存储映像，称为==结点==（Node）。

==n个结点（a~i~的存储映像）链结成一个链表，即为线性表（a~1~，a~2~，··· ， a~n~）的链式储存结构==，因为此链表的每个结点中只包含一个指针域，所以叫做==单链表==。单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起。

我们把==链表中第一个结点的存储位置叫做头指针==。最后一个结点就意味着直接后继不存在了，所以我们规定，线性链表的最后一个结点指针为 “空” （通常用NULL或 “^” 符号表示）。

有时为了更加方便地对链表进行操作，会在==单链表的第一个结点前附设一个结点，称为头结点==。头结点的指针域存储指向第一个结点的指针。

###  3.5.2 头指针与头结点的异同

头指针：

+ 头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针
+ 头指针具有标志作用，所以常用头指针冠以链表的名字
+ 无论链表是否为空，头指针均不为空。头指针是链表的必要元素

头结点：

+ 头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）
+ 有了头结点，对在第一元素结点前插入终点和删除第一结点，其操作与其他结点的操作就统一了
+ 头结点不一定是链表必需元素

### 3.5.3 线性表链式存储结构代码描述

单链表中，我们在C语言中可用结构指针来描述

~~~html
/*线性表的单链表存储结构*/
typedef struct Node
{
	ElemType data; //代表数据域
	struct Node *next; //代表指针域，指向直接后置元素  
}Node; //Node为结点名，每个结点都是一个 Node 结构体
typeof struct Node *LinkList; //定义LinkList 
~~~

## 3.6 单链表的读取

获得链表第 i 个数据的算法思路：

1. 声明一个指针p指向链表第一个结点，初始化 j 从1开始
2. 当 j < i 时，就遍历链表，让p的指针向后移动，不断指向下一结点，j 累加1
3. 若到链表末尾p为空，则说明第 i 个结点不存在
4. 否则查找成功，返回结点p的数据

实现代码算法如下：
~~~html
/*初始条件：链式线性表L已存在，1<=i<=ListLength(L)*/
/*操作结果：用e返回L中第i个数据元素的值*/
Status GetElem(LinkList L,int i,ElemType *e)
{
	int j;
	LinkList p; //声明一结点p
	p = L->next; //让p指向链表L的第一个结点 
	j = 1; //j为计数器
	while(p && j < i) //p不为空或者计数器j还没有等于i时，循环继续 
	{
		p = p->next; //让p指向下一个结点
		++j; 
	}
	if( !p || j>1)
	{
		return ERROR; //第i个元素不存在 
	}
	*e = p->data; //取第i个元素的数据 
	return OK;   
}
~~~

## 3.7 单链表的插入和删除

### 3.7.1 单链表的插入

 ![image-20231113111957110](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20231113111957110.png)

实现的代码如下：

~~~html
s->next = p->next;  //将p的后继结点赋值给s的后继
p->next = s; //将s赋值给p的后继
~~~

也就是说让p的后继结点改成s的后继结点，再把结点s变成p的后继结点（如下图所示）：

![](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230211_140012.png)

单链表第 i 个数据插入结点的算法思路：

1. 声明一指针p指向链表头结点，初始化 j 从1开始
2. 当 j < i 时，就遍历链表，让p的指针向后移动，不断指向下一结点，j 累加1
3. 若到链表末尾p为空，则说明第 i 个结点不存在
4. 否则查找成功，在系统中生成一个空结点s
5. 将数据元素e赋值给s->data
6. 单链表的插入标准语句s->next=p->next;  p->next=s;
7. 返回成功

实现代码如下：
~~~html
/*初始条件：链式线性表L已存在，1<=i<=ListLength(L)*/
/*操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1*/
Status ListInsert(LinkList *L,int i,ElemType e)
{
	int j;
	LinkList p,s;
	p = *L;
	j = i;
	while(p && j < i) //寻找第i个结点 
	{
		p = p->next;
		++j;
	}
	if(!p || j > i)
	{
		return ERROR; //第i个元素不存在 
	}
	s = (LinkList)malloc(sizeof(Node));  //生成新结点(C语言标准库函数)
	s->data = e;
	s->next = p->next;  //将p的后继结点赋值给s的后继 
	p->next = s;  //将s赋值给p的后继
	return OK; 
} 
~~~

这段代码用到的malloc标准函数，它的作用就是生成一个新的结点，其类型与Node是一样的，其实质就是在内存中找了一小块空地，准备用来存放数据e的s结点。

### 3.7.2 单链表的删除

![](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230211_181818.png)

设存储元素a~i~的结点为q，要实现将结点q删除单链表的操作，其实就是将它的前继结点的指针绕过，指向它的后继结点即可。

实现代码如下：
~~~html
q = p->next;
p->next = q->next; //将q的后继赋值给p的后继
~~~

单链表第 i 个数据删除结点的算法思路：

1. 声明一指针p指向链表头结点，初始化 j 从1开始
2. 当 j < i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j 累加1
3. 若到链表末尾p为空，则说明第 i 个结点不存在
4. 否则查找成功，将欲删除的结点p->next赋值给q
5. 单链表的删除标准语句p->next=q->next
6. 将q结点中的数据赋值给e，作为返回
7. 释放q结点
8. 返回成功

实现代码算法如下：
~~~html
/*初始条件：链式线性表L已存在，1<=i<=ListLength(L)*/
/*操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1*/
Status ListDelete(LinkList *L,int i,ElemType *e)
{
	int j;
	LinkList p,q;
	p = *L;
	j = 1;
	while(p->next && j < i) //遍历寻找第i个元素 
	{
		p = p->next;
		++j;
	}
	if(!(p->next) || j > i)
	{
		return ERROR; //第i个元素不存在 
	}
	q = p->next;
	p->next = q->next; //将q的后继赋值给p的后继
	*e = q->data; //将q结点中的数据给e
	free(q); //让系统收回此结点，释放内存
	return OK; 
} 
~~~

这段代码中的标准函数free，它的作用就是让系统回收一个Node结点，释放内存

==对于插入或删除数据越频繁的操作，单链表的效率优势就越明显==

## 3.8 单链表的整表创建

创建单链表的过程就是一个动态生成链表的过程。即从“空表”的初始状态起，依次建立各元素结点，并逐个插入链表

1. 声明一指针p和计数器变量 i
2. 初始化一空链表L
3. 让L的头结点的指针指向NULL，即建立一个带头结点的单链表
4. 循环：
   1. 生成一新结点赋值给p
   2. 随机生成一数字赋值给p的数据域p->data
   3. 将p插入到头结点与前一新结点之间

实现代码算法如下：
~~~html
/*随机产生n个元素的值，建立带表头结点的单链线性表L(头插法)*/
void CreateListHead(LinkList *L,int n)
{
	LinkList p;
	int i;
	srand(time(0)); //初始化随机数种子
	*L = (LinkList)malloc(sizeof(Node)); 
	(*L)->next = NULL; //先建立一个带头结点的单链表
	for(i=0; i<n; i++)
	{
		p = (LinkList)malloc(sizeof(Node)); //生成新结点
		p->data = rand()%100+1; //随机生成100以内的数字
		p->next = (*L)->next;
		(*L)->next = p; //插入到表头  
	} 
}
~~~

这段算法代码里，始终让新结点在第一的位置，把这种算法简称为==头插法==。

![](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230213_223713.png)

如果我们把每次新结点都插在终端结点的后面，这种算法称之为==尾插法==。

实现代码算法如下：
~~~html
/*随机产生n个元素的值，建立带表头结点的单链线性表L(尾插法)*/
void CreateListTail(LinkList *L,int n)
{
	LinkList p;
	int i;
	srand(time(0)); //初始化随机数种子
	*L = (LinkList)malloc(sizeof(Node)); //L为整个线性表 
	r = *L; //r为指向尾部的结点 
	for(i=0; i<n; i++)
	{
		p = (Node *)malloc(sizeof(Node)); //生成新结点
		p->data = rand()%100+1; //随机生成100以内的数字
		r->next=p; //将表尾端结点的指针指向新结点
		r = p; //将当前的新结点定义为表尾终端结点 
	} 
	r->next = NULL; //表示当前链表结束 
}
~~~

r->next=p;的意思，其实就是将刚才的表尾终端结点r的指针指向新结点p

![](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230213_223815.png)

r=p;的意思，就是本来r是在a~i-1~元素的结点，可现在它已经不是最后的结点了，现在最后的结点是a~i~，所以应该让p结点这个最后的结点赋值给r。此时r又是最终的尾部结点了。

![](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230213_223943.png)

循环结束后，应该让这个结点的指针域置空，因此有了 r->next=NULL; 以便确认以后遍历时可以确认其是尾部

## 3.9 单链表的整表删除

单链表整表删除的算法思路如下：

1. 声明一指针p和q
2. 将第一个结点赋值给p
3. 循环
   1. 将下一结点赋值给q
   2. 释放p
   3. 将q赋值给p

实现代码算法如下：
~~~html
/*初始条件：链式线性表L已存在。操作结果：将L重置为空表*/
Status ClearList(LinkList *L)
{
	LinkList p,q;
	p=(*L)->next; //p指向第一个结点
	while(p) //没到表尾 
	{
		q=p->next;
		free(p);
		p=q;
	} 
	(*L)->next=NULL; //头结点指针域为空
	return OK; 
} 
~~~

## 3.10 单链表结构与顺序存储结构的优缺点

+ 若线性表需要频繁查找，很少进行插入和删除操作时，宜采用==顺序存储结构==
+ 当线性表中的元素个数变化较大或者根本不知道有多大时，最好用==单链表结构==

## 3.11 静态链表

==用数组描述的链表叫做静态链表==

首先我们让数组的元素都是由两个数据域组成，data和cur。也就是说，数组的每个下标都对应一个data和一个cur。数据域data，用来存放数据元素，也就是通常我们要处理的数据；而cur相当于单链表中的next指针，存放该元素的后继在数组中的下标，我们把cur叫做游标。

实现代码如下：
~~~html
#define MAXSIZE 1000 //存储空间初始分配量

//线性表的静态链表储存结构
typedef struct
{
	ElemType data;
	int cur; //游标(Cursor)，为0时表示无指向 
} Component,StaticLinkList[MAXSIZE];
~~~

![](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230212_142247.png)

此时的图示相当于初始化的数组状态，见下面代码：

~~~html、
/*将一维数组space中各分量链成一个备用链表，space[0].cur为头指针，"0"表示空指针*/
Status InitList(StaticLinkList sapce)
{
	int i;
	for(i=0; i<MAXSIZE; i++)
	{
		space[i].cur = i+1;
	}
	space[MAXSIZE-1].cur = 0; //目前静态链表为空，最后一个元素的cur为0
	return OK; 
} 
~~~

### 3.11.1静态链表的插入操作

在动态链表中，结点的申请和释放分别用malloc()和free()两个函数来实现。在静态链表中，操作的是数组，不存在像动态链表的结点申请和释放问题，所以我们需要自己实现这两个函数，才可以做插入和删除的操作。

为了辨明数组中哪些分量未被使用，解决的办法是将所有未被使用过的及已被删除的分量用游标链成一个备用的链表，每当进行插入时，便可以从备用链表上取得第一个结点作为待插入的新结点。

~~~html
/*若备用空间链表非空，则返回分配的结点下标，否则返回0*/
int Malloc_SSL(StaticLinkList sapce)
{
	int i = space[0].cur; //当前数组第一个元素的cur存的值
	                      //就是要返回的第一个备用空闲的下标
	if(sapce[0].cur)
	{
		space[0].cur = space[i].cur; //由于要拿出一个分量来使用，所以我们就把它的下一个分量用来做备用 
	}					  
	return i; 
} 
~~~

  ![](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230212_145317.png)

实现代码如下，代码左侧为行号：
~~~html
Status ListInsert(StaticLinkList L, int i, ElemType e)
{
	int j, k, l;
	k = MAXSIZE - 1; //注意k首先是最后一个元素的下标 
	if(i < 1 || i > ListLength(L) + 1)
		return ERROR; 
	j = Malloc_SSL(L); //获得空闲分量的下标
	if(j)	
	{
		L[j].data = e; //将数据赋值给此分量的data
		for(l = 1; l<= i - 1; l++) //找到第i个元素之前的位置 
			k = L[k].cur; 
		L[j].cur = L[k].cur; //把第i个元素之前的cur赋值给新元素的cur
		L[k].cur = j; //把新元素的下标赋值给第i个元素之前元素的cur
		return OK;	
	}
	return OK;
}
~~~

（1）当我们执行插入语句时，我们的目的是要在 “乙” 和 “丁” 之间插入 “丙”。调用代码时，输入 i 值为3
（2）第4行让k=MAX_SIZE-1=999
（3）第7行，j=Malloc_SSL(L)=7。此时下标为0的cur也因为7要被占用而更改备用链表的值为8
（4）第11和第12行，for循环由1到2，执行两次。代码k = L[k].cur; 使得k=999，得到k=L[999].cur=1，再得到k=L[1].cur=2
（5）第13行，L[j].cur = L[k].cur;因j=7，而k=2得到L[7].cur=L[2].cur=3。这就是刚才我说的让 “丙” 把它的cur改为3的意思
（6）第14行，L[k].cur = j;意思就是L[2].cur=7。也就是让 "乙" 把它的cur改为指向 "丙" 的下标7

### 3.11.2 静态链表的删除操作

和前面一样，删除元素时，原来是需要释放结点的函数free()。现在我们也得自己实现它：
~~~html
//删除在L中第i个数据元素
Status ListDelete(StaticLinkList L, int i)
{
	int j, k;
	if(i < 1 || i > ListLength(L))
		return ERROR;
	k = MAXSIZE - 1;
	for(j = 1; j <= i -1; j++)
		k = L[k].cur;
	j = L[k].cur;
	L[k].cur = L[j].cur;
	Free_SSL(L, j);
	return OK;	
} 
~~~

前面代码都一样，for循环因为i=1而不操作，j=L[999].cur=1，L[k].cur=L[j].cur也就是L[999].cur=L[1].cur=2。这其实就是告诉计算机现在 "甲" 已经离开了，“乙” 才是第一个元素。Free_SSL(L,j);是什么意思？来看代码：
~~~html
//将下标为k的空闲结点回收到备用链表
void Free_SSL(StaticLinkList space, int k)
{
	space[k].cur = space[0].cur; //把第一个元素的cur值赋给要删除的分量cur 
	space[0].cur = k; //把要删除的分量下标赋值给第一个元素的cur 
} 
~~~

意思就是 “甲” 现在要走，这个位置就空出来，也就是，未来如果有新人要来，最优先考虑这里，所以原来的第一个空位分量，即下标是8的分量，它降级了，把8给 “甲”所在下标为1的分量的cur，也就是space[1].cur=space[0].cur=8，而space[0].cur=k=1其实就是让这个删除的位置成为第一个优先空位，把它存入第一个元素的cur中。

当然静态链表也有相应的其他操作的相关实现。比如我们代码中的ListLength就是一个，来看代码：
~~~html
/*初始条件：静态链表L已存在。操作结果：返回L中数据元素的个数*/
int ListLength(StaticLinkList L)
{
	int j = 0;
	int i = L[MAXSIZE-1].cur;
	while(1)
	{
		i=L[i].cur;
		j++;
	}
	return j;
} 
~~~

### 3.11.3 静态链表的优缺点

优点：在插入和删除操作时，只需要修改图标，不需要移动元素，从而改进了在顺序存储结构中插入和删除操作需要移动大量元素的缺点
缺点：没有解决连续存储分配带来的表长难以确定的问题
           失去了顺序存储结构随机存取的特性

## 3.12 循环链表

将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称==循环链表(circular linked list)==

举个程序的例子，要将两个循环链表合并成一个表时，有了尾指针就非常简单了。比如下面的这两个循环链表，它们的尾指针分别是rearA和rearB，如下图所示：

![](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230212_165015.png)

要想把它们合并，只需要如下的操作即可。

![](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230212_165120.png)

~~~html
p=rearA->next; //保存A表的头结点
rearA->next=rearB->next->next; //将本是指向B表的第一个结点（不是头结点）赋值给rearA->next
q=rearB->next; 
rearB->next=p; //将原A表的头结点赋值给rearB->next
free(q); //释放q
~~~

## 3.13 双向链表

==双向链表（double linked list）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域==

所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。

~~~html
//线性表的双向链表存储结构
typedef struct DuLNode
{
	ElemType data;
	struct DuLNode *prior; //直接前驱指针
	strcut DuLNode *next; //直接后继指针 
} DuLNode, *DuLinkList; 
~~~

双向链表的循环带头结点的空链表如下图所示：
![](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230212_172415.png)

非空的循环带头结点的双向链表如下图所示：
![](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230212_172513.png)

~~~html
p->next->prior = p = p->prior->next
~~~

插入操作时，顺序很重要
我们假设存储元素e的结点为s，要实现将结点s插入到结点p和p->next之间需要下面几步，如下图所示：
![](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230212_172823.png)

~~~html
s->prior = p; //把p赋值给s的前驱，如图中①
s->next = p->next; //把p->next赋值给s的后继，如图中②
p->next->prior = s; //把s赋值给p->next的前驱，如图中③
p->next = s; //把s赋值给p的后继，如图中④
~~~

==顺序是先搞定s的前驱和后继，再搞定后结点的前驱，最后解决前结点的后驱==

若要删除结点p，只需要下面两个步骤：

![](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230212_173827.png)

~~~html
p->prior->next = p->next; //把p->next赋值给p->prior的后继
p->next->prior = p->prior; //把p->prior赋值给p->next的前驱
free(p); //释放结点
~~~

# 4、栈与队列

## 4.1 栈的定义

类似弹夹中的子弹一样先进去，却要后出来，而后进的，反而可以先出来的数据结构——栈。

==栈（stack）是限定仅在表尾进行插入和删除操作的线性表==

我们把==允许插入和删除的一端称为栈顶（top），另一端称为栈底（bottom），不含任何数据元素的栈称为空栈。栈又称为后进先出（Last In First Out）的线性表，简称LIFO结构==。

栈是一种特殊的线性表，它的特殊之处在于限制了这个线性表的表尾进行插入和删除操作，它始终只在栈顶进行。这也就使得：栈底是固定的，最先进栈的只能在栈底。

==栈的插入操作，叫作进栈，也称压栈、入栈。==
==栈的删除操作，叫作出栈，有的也叫作弹栈。==

## 4.2 栈的抽象数据类型

> ADT 栈（stack）
> Data
>         同线性表。元素具有相同数据类型，相邻元素具有前驱和后继关系。
> Operation
>         InitStack( *S)：初始化操作，建立一个空栈s。
>         DestroyStack( *S)：若栈存在，则销毁它。
>         ClearStack( *S)：将栈清空。
>         StackEmpty(S)：若栈为空，返回 true，否则返回 false。
>         GetTop(S, *e)：若栈存在且非空，用 e 返回 S 的栈顶元素。
>         Push( *S,e)：若栈S存在，插入新元素 e 到栈S中并成为栈顶元素。
>         Pop( *S, *e)：删除栈S中栈顶元素，并用 e 返回其值。
>         StackLength(S)：返回栈S的元素个数。

## 4.3 栈的顺序存储结构及实现

### 4.3.1 栈的顺序存储结构

==栈的顺序存储结构==其实也是线性表存储的简化，我们称为==顺序栈==。

我们定义一个top变量来指示栈顶元素在数组中的位置，栈顶的top可以变大变小，但无论如何游标不能超出尺的长度。同理，若存储栈的长度为StackSize，则栈顶位置top必须小于StackSize。当栈存在一个元素时，top等于0，因此通常把空栈的判定条件定为top等于-1。

来看栈的结构定义：
~~~html
typedef int SElemType; //SElemType类型根据实际情况而定，这里假设为int

//顺序栈结构
typedef struct
{
	SElemType data[MAXSIZE];
	int top; //用于栈顶指针 
}SqStack;
~~~

### 4.3.2 栈的顺序存储结构——进栈操作

![](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230214_141306.png)

因此对于进栈操作push，其代码如下：
~~~html
//插入元素e为新的栈顶元素
Status Push(SqStack *S,SElemType e)
{
	if(S->top == MAXSIZE - 1) //栈满 
	{
		return ERROR;
	}
	S->top++; //栈顶指针增加一
	S->data[S->top]=e; //将新插入元素赋值给栈顶空间
	return OK; 
} 
~~~

### 4.3.3 栈的顺序存储结构——出栈操作

出栈操作pop，代码如下：
~~~html
//若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR
Status Pop(SqStack *S,SElemType *e)
{
	if(S->top==-1)
		return ERROR;
	*e=S->data[S->top]; //将要删除的栈顶元素赋值给e
	S->top--; //栈顶指针减一 
	return OK;	
} 
~~~

## 4.4 两栈共享空间

如果我们有两个相同类型的栈，我们为它们各自开辟了数组空间，极有可能是第一个栈已经满了，再进栈就溢出了，而另一个栈还有很多存储空间空闲。我们完全可以用一个数组来存储两个栈，充分利用这个数组占用的内存空间。

我们的做法如下图，数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为数组的末端，即下标为数组长度n-1处。这样，两个栈如果增加元素，就是两端点向中间延伸。

![](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230215_164606.png)

其实关键思路是：它们是在数组的两端，向中间靠拢。top1和top2是栈1和栈2的栈顶指针，可以想象，只要它们俩不见面，两个栈就可以一直使用。
栈1为空时，就是top1等于-1时；而当top2等于n时，即是栈2为空时。
若栈2是空栈，栈1的top1等于n-1时，就是栈1满了。反之，当栈1为空栈时，top2等于0时，栈2满。但更多的情况，两个栈见面之时，也就是两个指针之间相差1时，即top1+1=top2为栈满。
两栈共享空间结构的代码如下：

~~~html
//两栈共享空间结构
typedef struct
{
	SElemType data[MAXSIZE];
	int top1; //栈1栈顶指针
	int top2; //栈2栈顶指针 
}SqDoubleStack; 
~~~

对于两栈共享空间的push方法，我们除了要插入元素值参数外，还需要有一个判断是栈1还是栈2的栈号参数stackNumber。插入元素的代码如下：
~~~html
//插入元素e为新的栈顶元素
Status Push(SqDoubleStack *S,SElemType e,int StackNumber)
{
	if(S->top1+1==S->top2) //栈已满，不能再push新元素 
		return ERROR;
	if(stackNumber==1) //栈1有元素进栈 
		S->data[++S->top1]=e; //若是栈1则先top1+1后给数组元素赋值
	else if(stackNumber==2)
		S->data[--S->top2]=e; //若是栈2则先top2-1后给数组元素赋值
	return OK;	 
} 
~~~

对于两栈共享空间的pop方法，参数就只是判断栈1栈2的参数satckNumber，代码如下：
~~~html
//若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR
Status Pop(SqDoubleStack *S,SElemType *e,int stackNumber)
{
	if(stackNumber==1)
	{
		if(S->top1==-1)
			return ERROR; //说明栈1已经是空栈，溢出
		*e=S->data[S->top1--]; //将栈1的栈顶元素出栈	 
	}
	else if(stackNumber==2)
	{
		if(S->top2==MAXSIZE)
			return ERROR; //说明栈2已经是空栈，溢出
		*e=S->data[S->top2++]; //将栈2的栈顶元素出栈	 
	}
	return OK; 
} 
~~~

## 4.5 栈的链式结构存储及实现

### 4.5.1 栈的链式存储结构

==栈的链式存储结构，简称为链栈。==

栈只是栈顶来做插入和删除操作，比较好的方法就是把栈顶放在单链表的头部（如下图所示）。另外，都已经有了栈顶在头部了，单链表中比较常见的头结点也就失去了意义，通常对于链栈来说，是不需要头结点的。
![](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230216_153220.png)

对于空栈来说，链表原定义啊是头指针指向空，那么链栈的空其实就是top=NULL的时候。
链栈的结构代码如下：

~~~html
//链栈结构
typedef struct StackNode
{
	SElemType data;
	struct StackNode *next; 
}StackNode,*LinkStackPtr;

typedef struct
{
	LinkStackPtr top;
	int count;
}LinkStack;
~~~

### 4.5.2 栈的链式存储结构——进栈操作

对于链栈的进栈push操作，假设元素值为e的新结点是s，top为栈顶指针，示意图如下所示，代码如下：

![image-20230216160922050](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230216160922050.png)

~~~html
//插入元素e为新的栈顶元素
Status Push(LinkStack *S,SElemType e)
{
	LinkStackPtr s=(LinkStackPtr)malloc(sizeof(StackNode));
	s->data=e;
	s->next=S->top; //把当前栈顶元素赋值给新结点的直接后继,见图中① 
	S->top=s; //将新结点s赋值给栈顶指针，见图中② 
	S->count++;
	return OK; 
} 
~~~

### 4.5.3 栈的链式存储结构——出栈操作

链栈的出栈pop操作，假设变量p用来存储要删除的栈顶结点，将栈顶指针下移一位，最后释放p即可，如下图所示：

![image-20230216162536586](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230216162536586.png)

~~~html
//若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR
Status Pop(LinkStack *S,SElemType *e)
{
	LinkStackPtr p;
	if(StackEmpty(*S))
		return ERROR;
	*e=S->top->data;
	p=S->top; //将栈顶结点赋值给p，见图中③
	S->top=S->top->next; //使得栈顶指针下移一位，指向后一结点，见图中④
	free(p); //释放结点p
	S->count--;
	return OK;	 
} 
~~~

链栈的进栈push和出栈pop操作都很简单，没有任何循环操作，时间复杂度均为O(1)。
==如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些。==

## 4.6 栈的作用

==栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。==

## 4.7 栈的应用——递归

### 4.7.1 斐波拉契数列的实现

| 所经过的月数 | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |
| ------------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 兔子对数     | 1    | 1    | 2    | 3    | 5    | 8    | 13   | 21   | 34   | 55   | 89   | 144  |


打印前四十位斐波拉契数列，递归代码如下：

~~~html
//斐波拉契的递归函数
#include<iostream>
using namespace std;

int Fbi(int i)
{
	if(i < 2)
		return i == 0 ? 0 : 1;
	return Fbi(i-1)+Fbi(i-2); //这里Fbi就是函数自己，等于在调用自己	
}

int main()
{
	int i;
	cout << "递归显示斐波拉契数列： ";
	for(i = 0; i < 40; i++)
		cout << Fbi(i) << endl;
	return 0;	
}
~~~

### 4.7.2 递归的定义

==我们把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数。==
每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。

递归为何于栈有关系。简单地说，就是在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中。在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态。

## 4.8 栈的应用——四则运算表达式求值

### 4.8.1 后缀（逆波兰）表示法的定义

==一种不需要括号的后缀表达法，我们也把它称为逆波兰（Reverse Polish Notation，RPN）表示==

对于 “9+(3-1)✖3+10➗2”，要用后缀表示法应该是什么样子
正常数学表达式：9+(3-1)✖3+10➗2
后缀表达式：9 3 1-3 * + 10 2 / +
这样的表达式称为==后缀表达式==。叫后缀的原因在于==所有的符号都是在要运算数字的后面出现==

### 4.8.2 后缀表达式的计算结果

后缀表达式：9 3 1-3 * + 10 2 / +
规则：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果出栈，一直到最终获得结果。

![image-20230217195923476](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230217195923476.png)（1）初始化一个空栈。此栈用来对要运算的数字进出使用，如左图所示。
![image-20230217195954661](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230217195954661.png)（2)后缀表达式中前三个都是数字，所以9、3、1进栈，如左图所示。

![image-20230217200359149](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230217200359149.png)（3)接下来是 “ - ”，所以将栈中的1出栈作为减数，3出栈作为被减数，并运算3-1得到2，再将2进栈。

![image-20230217200449706](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230217200449706.png)（4)接着是数字3进栈。

![image-20230217200637415](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230217200637415.png)（5)后面是 “ * ”，也就意味着栈中3和2出栈，2与3相乘，得到6，并将6出栈。

![image-20230217200748541](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230217200748541.png)（6)下面是 “+”，所以栈中6和9出栈，9与6相加，得到15，将15进栈。

![image-20230217200828982](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230217200828982.png)（7)接着是10与2两数字进栈。

![image-20230217201018682](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230217201018682.png)（8)接下来是符号 “ / ”，因此，栈顶的2与10出栈，10与2相除，得到5，将5进栈。

![image-20230217201137791](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230217201137791.png)（9)最后一个符号是 “+”，所以15与5出栈并相加，得到20，将20进栈。

![image-20230217201215520](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230217201215520.png)（10)结果是20出栈，栈变为空

### 4.8.3 中缀表达式转后缀表达式

中缀表达式“9+(3-1)✖3+10➗2”转化为后缀表达式“ 9 3 1-3 * + 10 2 / + ”。
规则：从左到右遍历中缀表达式每个数字和符号，若是数字就输出，即称为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。

（1）初始化一空栈，用来对符号进出栈使用。

![image-20230217202130616](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230217202130616.png)

（2）第一个字符是数字9，输出9，后面是符号 “+”，进栈。

![image-20230217202221874](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230217202221874.png)

（3）第三个字符是“ ( ”，依然是符号，因其只是左括号，还未配对，故进栈。

![image-20230217202337679](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230217202337679.png)

（4）第四个字符是数字3，输出，总表达式为9 3，接着是 “-”，进栈。

![image-20230217202434524](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230217202434524.png)

（5）接下来是数字1，输出，总表达式为9 3 1，后面是符号 “ ) ”，此时，我们需要去匹配此前的 “ ( ”，所以栈顶依次出栈，并输出，直到 “ ) ”出栈为止。此时左括号上方只有 “-”，因此输出 “-”。总的输出表达式为 9 3 1 - 。

![image-20230217202826048](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230217202826048.png)

（6）紧接着是符号 “ * ”，因为此时的栈顶符号为 “ + ”，优先级低于 “ * ”，因此不输出，“ * ” 进栈。接着是数字3，输出，总的表达式为 9 3 1 -3。

![image-20230217203158727](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230217203158727.png)

（7）之后是符号 “ + ”，此时当前栈顶元素 “ * ” 比这个 " + "的优先级高，因此栈中元素出栈并输出（没有比 “ + ”更低的优先级，所以全部出栈），总输出表达式为9 3 1 -3 * +。然后将当前这个符号 “ + ”进栈。

![image-20230217203701649](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230217203701649.png)

（8）紧接着数字10，输出，总表达式变为9 3 1-3 * + 10。后是符号 “ / ”，所以 “ / ”进栈。

![image-20230217203839125](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230217203839125.png)

（9）最后一个数字2，输出，总的表达式变为9 3 1-3 * + 10 2。

![image-20230217203957657](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230217203957657.png)

（10）因为已经到最后，所以将栈中符号全部出栈并输出。最终输出的后缀表达式结果为9 3 1 - 3 * + 10 2 / +。

![image-20230217204154095](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230217204154095.png)

让计算机具有处理我们通常的标准（中缀）表达式的能力，最重要的就是以下两步：
（1）将中缀表达式转化为后缀表达式（栈用来进出运算的符号）
（2）将后缀表达式进行运算得出结果（栈用来进出运算的数字）

## 4.9 队列的定义

> ==队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表==

==队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。==假设队列是q=(a~1~,a~2~,···,a~n~)，那么a~1~就是队头元素，而a~n~是队尾元素。这样我们就可以删除时总是从a~1~开始，而插入时，列在最后。

## 4.10 队列的抽象数据类型

同样是线性表，队列也有类似线性表的各种操作，不同的就是插入数据只能在队尾进行，删除数据只能在队头进行。
>ADT 队列（Queue）
>Data
>        同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
>Operation
>        InitQueue( *Q)：初始化操作，建立一个空队列Q。
>        DestroyQueue( *Q)：若队列Q存在，则销毁它。
>        ClearQueue( *Q)：将队列Q清空。
>        QueueEmpty(Q)：若队列Q为空，返回true，否则返回false。
>        GetHead(Q, *e)：若队列Q存在且非空，用e返回队列Q的队头元素。
>        EnQueue( *Q,e)：若队列Q存在，插入新元素e到队列Q中并成为队尾元素。
>        DeQueue( *Q, *e)：删除队列Q中队头元素，并用e返回其值。
>        QueueLength(Q)：返回队列Q的元素个数。
>endADT

## 4.11 循环队列

### 4.11.1 队列循环存储的不足

我们假设一个队列有n个元素，则顺序存储的队列需建立一个大于n的数组，并把队列的所有元素存储在数组的前n个单元，数组下标为0的一端即是队头。所谓的入队列操作，其实就是在队尾追加一个元素，不需要移动任何元素，因此时间复杂度为O(1)，如下图所示。

![image-20230218131125529](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230218131125529.png)

与栈不同的是，队列元素的出列是在队头，即下标为0的位置，那也就意味着，队列中的所有元素都得向前移动，以保证队列的队头，也就是下标为0的位置不为空，此时时间复杂度为O(n)，如下图所示。

![image-20230218131351794](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230218131351794.png)

如果不去限制队列的元素必须存储在数组的前n个单元这一条件，出队的性能就会大大增加。也就是说，队头不需要一定在下标为0的位置，如下图所示。

![image-20230218132350736](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230218132350736.png)

为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指针，front指针指向队头元素，rear指针指向队尾元素的下一个位置这样当front等于rear时，此队列不是还剩一个元素，而是空队列。
假设是长度为5的数组，初始状态，空队列如左下图所示，front与rear指针均指向下标为0的位置。然后入队a~1~、a~2~、a~3~、a~4~，front指针依然指向下标为0位置，而rear指针指向下标为4的位置，如右下图所示。

![image-20230218133156384](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230218133156384.png)

出队a~1~、a~2~，则front指针指向下标为2的位置，rear不变，如左下图所示，再入队a~5~，此时front指针不变，rear指针移动到数组之外。

![image-20230218133427245](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230218133427245.png)

假设这个队列的总个数不超过5个，但目前如果接着入队的话，因数组末位数组元素已经占用，再向后加，就会产生数组越界的错误，可实际上，我们的队列在下标为0和1的地方还是空闲的。我们把这种现象叫做 “假溢出”。

### 4.11.2 循环队列的定义

==我们把队列的这种头尾相接的顺序存储结构称为循环队列==

上图的rear可以改为指向下标为0的位置，这样就不会造成指针指向不明的问题，如下图所示。

![image-20230218135030020](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230218135030020.png)

接着入队a~6~，将它放置于下标为0处，rear指针指向下标为1处，如左下图所示。若再入队a~7~，则rear指针就与front指针重合，同时指向下标为2的位置，如右下图所示。

![image-20230218135253415](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230218135253415.png)

+ 空队列时，front等于rear，现在当队列满时，也是front等于rear。
+ 办法一是设置一个标志变量flag，当front=rear，且flag=0时为队列空，当front=rear，且flag=1时为队列满。
+ 办法二是当队列空时，条件就是front=rear，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。例如左下图所示，我们就认为此队列已经满了，也就是说，我们不允许右上图情况出现。

![image-20230218144507456](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230218144507456.png)

重点讨论第二种方法，由于rear可能比front大，也可能比front小，所以尽管它们只相差一个位置时就是满的情况，但也可能是相差整整一圈。所以若队列的最大尺寸为QueueSize，那么`队列满的条件是（rear+1）%QueueSize == front`(取模“%”的目的就是为了整合rear与front大小为一个问题)。比如右上图，front=2而rear=1。（1+1）%5=2，所以此时队列也是满的。而对于下图，front = 2而rear = 0，(0+1)%5=1，1 ≠ 2，所以此时队列并没有满。

![image-20230218145952114](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230218145952114.png)

==通用的计算机队列长度的公式为：==

> ==(rear - front + QueueSize)%QueueSize==

循环队列的顺序存储结构代码如下：
~~~html
typedef int QElemType //QElemType类型根据实际情况而定，这里假设为int
//循环队列的顺序存储结构
typedef struct
{
	QElemType data[MAXSIZE];
	int front; //头指针
	int rear; //尾指针，若队列不空，指向队列尾元素的下一个位置 
}SqQueue;
~~~

循环队列的初始化代码如下：
~~~html
//初始化一个空队列Q
Status InitQueue(SqQueue *Q)
{
	Q->front=0;
	Q->rear=0;
	return OK;
} 
~~~

循环队列求队列长度的代码如下：
~~~html
//返回Q的元素个数，也就是队列的当前长度
int QueueLength(Squeue Q)
{
	return (Q.rear-Q.front+MAXSIZE)%MAXSIZE;
} 
~~~

循环队列的入队列操作代码如下：
~~~html
//若队列未满，则插入元素e为Q新的队尾元素
Status EnQueue(SqQueue *Q,QElemType e)
{
	if((Q->rear+1)%MAXSIZE == Q->front) //队列满的判断
		return ERROR;
	Q->data[Q->rear]=e; //将元素e赋值给队尾
	Q->rear=(Q->rear+1)%MAXSIZE; //rear指针向后移一位置，若到最后则转到数组头部 
	return OK;	  
} 
~~~

循环队列的出队列操作代码如下：
~~~html
//若队列不空，则删除Q中队头元素，用e返回其值
Status DeQueue(SqQueue *Q,QElemType *e)
{
	if(Q->front == Q->rear) //队列空的判断
		return ERROR;
	*e=Q->data[Q->front]; //将队头元素赋值给e
	Q->front=(Q->front+1)%MAXSIZE; //front指针向后移一位置，若到最后则转到数组头部
	return OK;	 
} 
~~~

## 4.12 队列的链式存储结构及实现

==队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列==。我们将队头指针指向链队列的头结点，而队尾指针指向终端结点。

![image-20230218153254061](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230218153254061.png)

空队列时，front和rear都指向头结点，如下图所示。

![image-20230218153337633](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230218153337633.png)

链队列的结构为：
~~~html
typedef int QElemType; //QElemType类型根据实际情况而定，这里假设为int

typedef struct QNode //结点结构
{
	QElemType data;
	struct QNode *next;
}QNode,*QueuePtr;

typedef struct //队列的链表结构 
{
	QueuePtr front,rear; //队头、队尾指针 
}LinkQueue;
~~~

### 4.12.1 队列的链式存储结构——入队操作

入队操作时，其实就是在链表尾部插入结点，如下图所示。
![image-20230218154801994](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230218154801994.png)

其代码如下：
~~~html
//插入元素e为Q的新的队尾元素
Status EnQueue(LinkQueue *Q,QElemType e)
{
	QueuePtr s=(QueuePtr)malloc(sizeof(QNode));
	is(!s) //存储分配失败
		exit(OVERFLOW);
	s->data=e;
	s->next=NULL;
	Q->rear->next=s; //把拥有元素e的新结点s赋值给原队尾结点的后继，如图① 
	Q->rear=s; //把当前的s设置为队尾结点，rear指向s，如图②
	return OK;	 
} 
~~~

### 4.12.2 队列的链式存储结构——出队操作

出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点。若链表除头结点外只剩一个元素，则需将rear指向头结点，如下图所示。

![image-20230218155931112](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230218155931112.png)

代码如下：
~~~html
//若队列不空，删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR
Status DeQueue(LinkQueue *Q,QElemType *e)
{
	QueuePtr p;
	if(Q->front==Q->rear)
		return ERROR;
	p=Q->front->next; //将欲删除的队头结点暂存给p，见图中①
	*e=p->data; //将欲删除的队头结点的值赋值给e
	Q->front->next=p->next; //将原队头结点的后继p->next赋值给头结点后继，见图中②
	if(Q->rear==p) //若队头就是队尾，则删除后将rear指向头结点，见图中③ 
		Q->rear=Q->front; 
	free(p);
	return OK;		
} 
~~~

==总的来说，在可以确定队列长度最大值的情况下，建议用循环内队列，如果你无法预估队列的长度，则用链队列。==

# 5.串

## 5.1 串的定义

==串（string）是由零个或多个字符组成的有限序列，又叫字符串==

==一般记为s= “a~1~a~2~···a~n~”（n>=0）==,其中，s是串的名称，用双引号括起来的字符序列是串的值。a~i~(1<=i<=n)可以是字母、数字或其他字符，i 就是该字符在串中的位置。==串中的字符数目n称为串的长度==，定义中谈到的 “有限” 是指长度n是一个有限的数值。==零个字符的串称为空串（null string）==，它的长度为零，可以直接用两个双引号 “ "" ” 表示，也可以用希腊字母 “ Φ ” 来表示。所谓的序列，说明串的相邻字符之间具有前驱和后继的关系。

空格串，是只包含空格的串。与空串的区别：空格串是有内容有长度的，而且可以不止一个空格。
子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串。
子串在主串中的位置就是子串的第一个字符在主串中的序号。

## 5.2 串的比较

事实上，串的比较是通过组成串的字符之间的编码来进行的，而字符的编码指的是字符在对应字符集中的序号。

==给定两个串：s= "a~1~a~2~···a~n~"，t=“b~1~b~2~···b~n~”，当满足以下条件之一时，s<t。==

==（1）n<m，且a~i~=b~i~（i = 1,2,···,n）==

==（2）存在某个k<=min（m，n），使得a~i~=b~i~（i = 1,2,···,k-1），a~k~ < b~k~。==

## 5.3 串的抽象数据类型

线性表更关注的是单个元素的操作，比如查找一个元素，插入或删除一个元素，但串中更多的是查找子串位置、得到指定位置子串、替换子串等操作。

> ADT 串（string）
> Data
> 串中元素仅由一个字符组成，相邻元素具有前驱和后继的关系。
> Operation
>     StrAssign(T, *chars)：生成一个其值等于字符串常量 chars 的串T。
>     StrCopy(T,S)：串 S 存在，由串 S 复制得串 T。
>     ClearString(S)：串 S 存在，将串清空。
>     StringEmpty(S)：若串 S 为空，返回 true，否则返回 false。
>     StrLength(S)：返回串 S 的元素个数，即串的长度。
>     StrCompare(S,T)：若 S > T，返回值 > 0，若 S = T，返回 0，若 S < T，返回值 <0。
>     Concat(T,S1,S2)：用 T 返回由 S1和 S2联接而成的新串。
>     SubString(Sub,S,pos,len)：串S存在，1<=pos<=StrLength(S)，且0<=len<=StrLength(S) -pos+1，用Sub返回串S的第pos个字符起长度为 len 的子串。
>     Index(S,T,pos)：串 S 和 T 存在，T是非空串，1<=pos<=StrLength(S)。若主串S中存在和串T值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置，否则返回0。
>     Replace(S,T,V)：串S、T和V存在，T是非空串。用V替换主串S中出现的所有与T相等的不重叠的子串。
>     StrInsert(S,pos,T)：串S和T存在，1<=pos<=StrLength(S)+1。在串S的第pos个字符之前插入串T。
>     StrDelete(S,pos,len)：串S存在，1<=pos<=StrLength(S)-len+1。从串S中删除第pos个字符起长度为 len 的子串。
> endADT

来看一个操作Index的实现算法。
~~~html
//T为非空串，若主串S中第pos个字符之后存在与T相等的子串
//则返回第一个这样的子串在S中的位置，否则返回0
int Index(String S,String T,int pos)
{
	int n,m,i;
	String sub;
	if(pos > 0)
	{
		n = StrLength(S); //得到主串S的长度
		m = Strlength(T); //得到子串T的长度
		i = pos;
		while(i <= n-m+1)
		{
			SubString(sub,S,i,m); //取主串中第i个位置开始长度与T相等的子串给sub
			if(StrCompare(sub,T) != 0) //如果两串不相等
				++i;
			else //如果两串相等 
				return i; //则返回i值 
		} 
	}
	return 0; //若无子串与T相等，返回0 
} 
~~~

## 5.4 串的存储结构

### 5.4.1 串的顺序存储结构

==串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的==。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。一般是用定长数组来定义。
既然是定长数组，就存在一个预定义的最大串长度，一般可以将实际的串长度值保存在数组的0下标位置。如下图所示。
![image-20230222214656586](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230222214656586.png)

对于串的顺序存储，有一些变化，串值的存储空间可在程序执行过程中动态分配而得。比如在计算机中存在一个自由存储区，叫做 “堆”。这个堆可由C语言的动态分配函数malloc()和free()来管理。

### 5.4.2 串的链式存储结构

对于串的链式存储结构，与线性表是相似的，但由于串结构的特殊性，结构中的每个元素数据是一个字符，如果也简单地应用链表存储串值，一个结点对应一个字符，就会存在很大的空间浪费。因此，一个结点可以存放一个字符，也可以考虑存放多个字符，最后一个结点若是未被占满时，可以用 “#” 或是其他非串值字符补全，如下图所示。
![image-20230222220140373](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230222220140373.png)

当然，这里一个结点存多少个字符才合适就变得很重要，这会直接影响着串处理地效率，需要根据实际情况做出选择。但串的链式存储结构除了在连接串与串操作时有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好。

## 5.5 朴素的模式匹配算法

==子串的定位操作通常称作串的模式匹配==

假设我们要从下面的主串S= “goodgoogle”中，找到T= “google” 这个子串的位置，我们通常需要下面的步骤。
（1）主串S第一位开始，S与T前三个字母都匹配成功，但S第四个字母是d而T的是g。第一位匹配失败。如下图所示，其中竖直连线表示相等。
![image-20230222222816235](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230222222816235.png)

（2）主串S第二位开始，主串S首字母是o，要匹配的T首字母是g，匹配失败，如下图所示。
![image-20230222222921434](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230222222921434.png)

（3）主串S第三位开始，主串S首字母是o，要匹配的T首字母是g，匹配失败，如下图所示。
![image-20230222223144688](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230222223144688.png)

（4）主串S第四位开始，主串S首字母是d，要匹配的T首字母是g，匹配失败，如下图所示。
![image-20230222223254159](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230222223254159.png)

（5）主串S第五位开始，S与T，6个字母全匹配，匹配成功，如下图所示。
![image-20230222223340639](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230222223340639.png)

我们假设主串S和要匹配的子串T的长度存在S[0]与T[0]中，实现代码如下：
~~~html
//返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0
//其中，T非空，1<=pos<=StrLength(S)
int Index(String S,String T,int pos)
{
	int i = pos; //i用于主串S中当前位置下标值，从pos位置开始匹配
	int j = 1; //j用于子串T当前位置下标值
	while (i <= S[0] && j <= T[0]) //当i小于S的长度并且j小于T的长度时，循环继续、
	{
		if(S[i] == T[j]) //两字母相等则继续
		{
			++i;
			++j;
		} 
		else //指针后退重新开始匹配 
		{
			i = i-j+2; //i退回到上次匹配首位的下一位
			j = 1; //j退回到子串T的首位 
		}
	}
	if(j > T[0])
		return i-T[0];
	else
		return 0; 
}
~~~

## 5.6 KMP模式匹配算法

==一个模式匹配算法，可以大大避免重复遍历的情况，我们把它称为克努特—莫里斯—普拉特算法，简称KMP算法。==

### 5.6.1 KMP模式匹配算法原理

==在需要查找字符串前，先对要查找的字符串做一个分析，这样可以大大减少我们查找的难度，提高查找的速度。==

我们把主串各个位置j值的变化定义为一个数组next，那么next的长度就是主串的长度，于是我们可以得到下面的函数定义：
$$ next[j]=\begin{cases}
0 & 当j = 1时 \\
Max{k|1<k<j，且'p~1~···p~k-1~'='p~j-k+1~···p~j-1~'} & 当此集合不为空时 \\
1 & 其他情况 
\end{cases}$$

### 5.6.2 next数组值的推导

（1）T= “abcdex”

| j       | 123456 |
| ------- | ------ |
| 模式串T | abcdex |
| next[j] | 011111 |

①当j = 1时，next[j]=0
②当j = 2时，j由1到j-1就只有字符 “a”，属于其他情况next[2]=1
③当j = 3时，j由1到j-1串是 “ab”，显然 “a” 与 “b” 不相等，属其他情况，next[3]=1
④以后同理，所以最终此T串的next[j]为011111

（2）T = “abcabx”

| j       | 123456 |
| ------- | ------ |
| 模式串T | abcabx |
| next[j] | 011123 |

①当j = 1时，next[1]=0
②当j = 2时，next[2]=1
③当j = 3时，next[3]=1
④当j = 4时，next[4]=1
⑤当j = 5时，此时j由1到j-1的串是 “abca”，前缀字符 “a” 与后缀字符 “a”相等，因此可以推算出k值为2，因此next[5]=2
⑥当j = 6时，j由1到j-1的串是 “abcab”，由于前缀字符 “ab” 与后缀 “ab”相等，所以next[6]=3
==我们可以根据经验得到如果前后缀一个字符相等，k值是2，两个字符相等k值是3，n个字符相等k值就是n+1==

（3）T = “ababaaaba”

| j       | 123456789 |
| ------- | --------- |
| 模式串T | ababaaaba |
| next[j] | 011234223 |

①当j = 1时，next[0] = 0
②当j = 2时，next[2] = 1
③当j = 3时，next[3] = 1
④当j = 4时，next[4] = 2
⑤当j = 5时，next[5] = 3
⑥当j = 6时，j由1到j-1的串是 “ababa”，由于前缀字符 “aba” 与后缀 “aba” 相等，所以next[6]=4
⑦当j = 7时，j由1到j-1的串是 “ababaa”，由于前缀字符 “ab” 与后缀 “aa” 并不相等，只有 “a” 相等，所以next[7]=2
⑧当j = 8时，j由1到j-1的串是 “ababaaa”，只有 “a” 相等，所以next[8]=2
⑨当j = 9时，j由1到j-1的串是 “ababaaab”，由于前缀字符 “ab” 与后缀 “ab” 相等，所以next[9]=3

（4）T = “aaaaaaaab”

| j       | 123456789 |
| ------- | --------- |
| 模式串T | aaaaaaaab |
| next[j] | 012345678 |

①当j = 1时，next[1] = 0
②当j = 2时，next[2] = 1
③当j = 3时，j由1到j-1的串是 “aa”，前缀字符 “a” 与后缀字符 “a” 相等，next[3] = 2
④当j = 4时，j由1到j-1的串是 “aaa”，由于前缀字符 “aa” 与后缀 “aa” 相等，所以next[4] = 3
⑤······
⑥当j = 9时，j由1到j-1的串是 “aaaaaaaa”，由于前缀字符 “aaaaaaa” 与后缀 “aaaaaaa” 相等，所以next[9] = 8

### 5.6.3 KMP模式匹配算法的实现

~~~html
//通过计算返回子串T的next数组
void get_next(String T, int *next)
{
	int i,k;
	i = 1;
	k = 0;
	next[1] = 0;
	while(i<T[0]) //此处T[0]表示串T的长度
	{
		if(k==0 || T[i]==T[k])
		{
			++i;
			++k;
			next[i] = k;
		} 
		else
			k = next[k]; //若字符不相同，则k值回溯 
	} 
} 
~~~

上面这段代码的目的就是为了计算出当前要匹配的串T的next数组。
~~~html
//返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0
//T非空，1<=pos<=StrLength(S)
int Index_KMP(String S, String T, int pos)
{
	int i = pos; //i用于主串S中当前位置下标值，从pos位置开始匹配
	int j = 1; //j用于子串T中当前位置下标值
	int next[255]; //定义—next数组
	get_next(T,next); //对串T作分析，得到next数组
	while (i <= S[0] && j <= T[0]) //当i小于S的长度并且j小于T的长度时，循环继续
	{
		if(j == 0 || S[i] == T[j]) //两字母相等则继续，与朴素算法相比增加了j=0的判断
		{
			++i;
			++j; 
		} 
		else //指针后退重新开始匹配 
		{
			j = next[j]; //j退回合适的位置，i值不变 
		}
	} 
	if (j > T[0])
		return i-T[0];
	else
		return 0;	 
} 
~~~

上面这段代码的while循环是真正在匹配查找。
==高光的==为相对于朴素匹配算法增加的代码，改动不算大，关键就是去掉了i值回溯的部分。对于get_next函数来说，若T的长度为m，因只涉及简单的单循环，其时间复杂度为O(m)，而由于i值的不回溯，使得Index_KMP算法效率得到了提高，while循环的时间复杂度为O(n)。因此，整个算法的时间复杂度为O(n+m)。相较于朴素模式匹配算法的O((n-m+1)*m)来说，要好一些。
KMP算法仅当模式与主串之间存在许多 “部分匹配” 的情况下才体现出它的优势，否则两者差异并不明显。

### 5.6.4 KMP模式匹配算法的改进

![image-20230226202241327](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230226202241327.png)

当中的②③④⑤步骤，其实是多余的判断。由于T串的第二、三、四、五位置的字符都与首位的 “a” 相等，那么可以用首位next[1]的值取代与它相等的字符后续next[j]的值，因此我们对求next()函数进行了改良。
假设取代的数组是nextval，增加了高光部分，代码如下：

~~~html
//求模式串T的next函数修正值并存入数组nextval
void get_nextval(String T,int *nextval)
{
	int i,k;
	i = 1;
	k = 0;
	nextval[1] = 0;
	while(i < T[0]) //此处T[0]表示串T的长度 
	{
		if(k==0 || T[i]==T[k]) //T[i]表示后缀的单个字符，T[k]表示前缀的单个字符 
		{
			++i;
			++k;
			if(T[i] != T[k]) //若当前字符与前缀字符不同，则当前的k为nextval在i位置的值 
				nextval[i] = k;
			else
				nextval[i] = nextval[k]; //如果与前缀字符相同，则将前缀字符的nextval值赋给nextval在i位置的值 
		}
		else
			k = nextval[k]; //若字符不相同，则k值回溯 
	}
} 
~~~

### 5.6.5 nextval数组值的推导

（1）T= “ababaaaba”

| j          | 123456789 |
| ---------- | --------- |
| 模式串T    | ababaaaba |
| next[j]    | 011234223 |
| nextval[j] | 010104210 |

先算出next数组的值分别为011234223，然后再分别判断：
①当j = 1时，nextval[1]=0
②当j = 2时，因第二位字符 “b” 的next值是1，而第一位就是 “a” ，它们不相等，所以nextval[2]=next[2]=1，维持原值
③当j = 3时，因为第三位字符 “a” 的next值为1，所以与第一位的 “a” 比较得知他们想等，所以nextval[3]=nextval[1]=0;如下图所示。
![image-20230226205534267](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230226205534267.png)

④当j = 4时，第四位的字符 “b” next值为2，所以与第二位的 “b”相比较得到结果相等，因此nextval[4]=nextval[1]，如下图所示：
![image-20230226205828099](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230226205828099.png)

⑤当j = 5时，next值为3，第五个字符 “a” 与第三个字符 “a” 相等，因此nextval[5]=nextval[3]=0
⑥当j = 6时，next值为4，第六个字符 “a” 与第四个字符 “b” 不相等，因此nextval[6]=4
⑦当j = 7时，next值为2，第七个字符 “a” 与第二个字符 “b” 不相等，因此nextval[7]=2
⑧当j = 8时，next值为2，第八个字符 “b” 与第二个字符 “b” 相等，因此naxtval[8]=nextval[2]=1
⑨当j = 9时，next值为3，第九个字符 “a” 与第三个字符 “a” 相等，因此nextval[9]=nextval[3]=0

（2）T= “aaaaaaaab”

| j          | 123456789 |
| ---------- | --------- |
| 模式串T    | aaaaaaaab |
| next[j]    | 012345678 |
| nextval[j] | 000000008 |

①当j = 1时，nextval[1]=0
②当j = 2时，next值为1，第二个字符与第一个字符相等，所以nextval[2]=nextval[1]=0
③同样的道理，其后都为0······
④当j = 9时，next值为8，第九个字符 “b” 与第八个字符 “a” 不相等，所以nextval[9]=8
总结改进过的KMP算法，它是在计算出next值的同时，如果a位字符与它next值指向b位的nextval值，如果不等，则该a位的nextval值就是它自己a位的next的值。

# 6.树

## 6.1 二叉树

### 6.1.1 二叉树的性质

经过前人的总结，二叉树具有以下几个性质：

1. 二叉树中，第 i 层最多有 2^i-1^ 个结点。
2. 如果二叉树的深度为 K，那么此二叉树最多有 2^k^-1 个结点。
3. 二叉树中，终端结点数（叶子结点数）为 n~0~，度为 2 的结点数为 n~2~，则 n~0~=n~2~+1。

> 性质 3 的计算方法为：对于一个二叉树来说，除了度为 0 的叶子结点和度为 2 的结点，剩下的就是度为 1 的结点（设为 n~1~），那么总结点 n=n~0~+n~1~+n~2~。
> 同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为 B，那么总结点数 n=B+1。而分枝数是可以通过 n~1~ 和 n~2~ 表示的，即 B=n~1~+2*n~2~。所以，n 用另外一种方式表示为 n=n~1~+2*n~2~+1。
> 两种方式得到的 n 值组成一个方程组，就可以得出 n~0~=n~2~+1。

### 6.1.2 满二叉树

如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。
![满二叉树示意图](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/09452HG8-1.gif)

满二叉树除了满足普通二叉树的性质，还具有以下性质：

1. 满二叉树中第 i 层的节点数为 2^n-1^个。
2. 深度为 k 的满二叉树必有 2^k^-1 个节点 ，叶子数为 2^k-1^。
3. 满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。
4. 具有 n 个节点的满二叉树的深度为 $\log_2 (n+1)$。

### 6.1.3 完全二叉树

如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。

![完全二叉树示意图](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/09452Mb5-2.gif)

如图所示是一棵完全二叉树，由于最后一层的节点没有按照从左到右分布，因此只能算作是普通的二叉树。

完全二叉树除了具有普通二叉树的性质，它自身也具有一些独特的性质，比如说，n 个结点的完全二叉树的深度为 ⌊$\log_2 n$⌋+1。

> ⌊$\log_2 n$⌋ 表示取小于 $\log_2 n$ 的最大整数。例如，⌊$\log_2 4$⌋ = 2，而 ⌊$log_2 5$⌋ 结果也是 2。

对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号，对于任意一个结点 i，完全二叉树还有以下几个结论成立。

1. 当 i>1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）
2. 如果 2 * i > n（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2 * i 。
3. 如果 2 * i + 1 > n ，则结点 i 肯定没有右孩子；否则右孩子是结点 2 * i+1 

## 6.2 二叉树的顺序存储结构

完全二叉树的顺序存储，仅需从根节点开始，按照层次依次将树中节点存储到数组即可。

![img](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/0946243158-1.gif)

例如，存储图 2 所示的完全二叉树，其存储状态如图 3 所示：

![image-20230403210221314](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230403210221314.png)

同样，存储由普通二叉树转化来的完全二叉树也是如此。例如，图 1 中普通二叉树的数组存储状态如图 4 所示：

![image-20230403210232038](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230403210232038.png)

## 6.3 二叉树链式存储结构

![普通二叉树示意图](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/094GL4H-0.gif)

如图 1 所示，此为一棵普通的二叉树，若将其采用链式存储，则只需从树的根节点开始，将各个节点及其左右孩子使用==链表==存储即可。因此，图 1 对应的链式存储结构如图 2 所示：

![二叉树链式存储结构示意图](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/094GJ2Z-1.gif)

由图 2 可知，采用链式存储二叉树时，其节点结构由 3 部分构成（如图 3 所示）：

- 指向左孩子节点的指针（Lchild）
- 节点存储的数据（data）
- 指向右孩子节点的指针（Rchild）

![二叉树节点结构](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/094GK034-2.gif)

该节点结构的C语言代码为：
~~~html
typedef struct BiTNode{
    TElemType data;//数据域
    struct BiTNode *lchild,*rchild;//左右孩子指针
    struct BiTNode *parent;
}BiTNode,*BiTree;
~~~

则表示图二中链式存储结构对应的 C 语言代码为：
~~~html
#include <stdio.h>
#include <stdlib.h>
#define TElemType int
typedef struct BiTNode{
    TElemType data;//数据域
    struct BiTNode *lchild,*rchild;//左右孩子指针
}BiTNode,*BiTree;
void CreateBiTree(BiTree *T){
    *T=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->data=1;
    (*T)->lchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->lchild->data=2;
    (*T)->rchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->rchild->data=3;
    (*T)->rchild->lchild=NULL;
    (*T)->rchild->rchild=NULL;
    (*T)->lchild->lchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->lchild->lchild->data=4;
    (*T)->lchild->rchild=NULL;
    (*T)->lchild->lchild->lchild=NULL;
    (*T)->lchild->lchild->rchild=NULL;
}
int main() {
    BiTree Tree;
    CreateBiTree(&Tree);
    printf("%d",Tree->lchild->lchild->data);
    return 0;
}
~~~

## 6.4 二叉树先序遍历(递归与非递归)

二叉树的先序遍历思想是：

1. 访问根节点；
2. 访问当前节点的左子树；
3. 若当前节点无左子树，则访问当前节点的右子树；

![img](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/094T644B-0.png)

上图采用先序遍历得到的序列是：

> 1,2,4,5,3,6,7

递归实现代码如下：
~~~html
#include <stdio.h>
#include <string.h>
#define TElemType int
//构造结点的结构体
typedef struct BiTNode{
    TElemType data;//数据域
    struct BiTNode *lchild,*rchild;//左右孩子指针
}BiTNode,*BiTree;
//初始化树的函数
void CreateBiTree(BiTree *T){
    *T=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->data=1;
    (*T)->lchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->rchild=(BiTNode*)malloc(sizeof(BiTNode));
  
    (*T)->lchild->data=2;
    (*T)->lchild->lchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->lchild->rchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->lchild->rchild->data=5;
    (*T)->lchild->rchild->lchild=NULL;
    (*T)->lchild->rchild->rchild=NULL;
    (*T)->rchild->data=3;
    (*T)->rchild->lchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->rchild->lchild->data=6;
    (*T)->rchild->lchild->lchild=NULL;
    (*T)->rchild->lchild->rchild=NULL;
    (*T)->rchild->rchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->rchild->rchild->data=7;
    (*T)->rchild->rchild->lchild=NULL;
    (*T)->rchild->rchild->rchild=NULL;
    (*T)->lchild->lchild->data=4;
    (*T)->lchild->lchild->lchild=NULL;
    (*T)->lchild->lchild->rchild=NULL;
}
//模拟操作结点元素的函数，输出结点本身的数值
void displayElem(BiTNode* elem){
    printf("%d ",elem->data);
}
//先序遍历
void PreOrderTraverse(BiTree T){
    if (T) {
        displayElem(T);//调用操作结点数据的函数方法
        PreOrderTraverse(T->lchild);//访问该结点的左孩子
        PreOrderTraverse(T->rchild);//访问该结点的右孩子
    }
    //如果结点为空，返回上一层
    return;
}
int main() {
    BiTree Tree;
    CreateBiTree(&Tree);
    printf("先序遍历: \n");
    PreOrderTraverse(Tree);
}
~~~

非递归实现代码：
~~~html
#include <stdio.h>
#include <string.h>
#define TElemType int
int top=-1;//top变量时刻表示栈顶元素所在位置
//构造结点的结构体
typedef struct BiTNode{
    TElemType data;//数据域
    struct BiTNode *lchild,*rchild;//左右孩子指针
}BiTNode,*BiTree;
//初始化树的函数
void CreateBiTree(BiTree *T){
    *T=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->data=1;
    (*T)->lchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->rchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->lchild->data=2;
    (*T)->lchild->lchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->lchild->rchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->lchild->rchild->data=5;
    (*T)->lchild->rchild->lchild=NULL;
    (*T)->lchild->rchild->rchild=NULL;
    (*T)->rchild->data=3;
    (*T)->rchild->lchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->rchild->lchild->data=6;
    (*T)->rchild->lchild->lchild=NULL;
    (*T)->rchild->lchild->rchild=NULL;
    (*T)->rchild->rchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->rchild->rchild->data=7;
    (*T)->rchild->rchild->lchild=NULL;
    (*T)->rchild->rchild->rchild=NULL;
    (*T)->lchild->lchild->data=4;
    (*T)->lchild->lchild->lchild=NULL;
    (*T)->lchild->lchild->rchild=NULL;
}
//前序遍历使用的进栈函数
void push(BiTNode** a,BiTNode* elem){
    a[++top]=elem;
}
//弹栈函数
void pop( ){
    if (top==-1) {
        return ;
    }
    top--;
}
//模拟操作结点元素的函数，输出结点本身的数值
void displayElem(BiTNode* elem){
    printf("%d ",elem->data);
}
//拿到栈顶元素
BiTNode* getTop(BiTNode**a){
    return a[top];
}
//先序遍历非递归算法
void PreOrderTraverse(BiTree Tree){
    BiTNode* a[20];//定义一个顺序栈
    BiTNode * p;//临时指针
    push(a, Tree);//根结点进栈
    while (top!=-1) {
        p=getTop(a);//取栈顶元素
        pop();//弹栈
        while (p) {
            displayElem(p);//调用结点的操作函数
            //如果该结点有右孩子，右孩子进栈
            if (p->rchild) {
                push(a,p->rchild);
            }
            p=p->lchild;//一直指向根结点最后一个左孩子
        }
    }
}
int main(){
    BiTree Tree;
    CreateBiTree(&Tree);
    printf("先序遍历: \n");
    PreOrderTraverse(Tree);
}
~~~

## 6.5 二叉树中序遍历(递归与非递归)

二叉树中序遍历实现的思想：

1. 访问当前节点的左子树；
2. 访问根节点；
3. 访问当前节点的右子树；

![img](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/09493A423-0.png)

上图二叉树采用中序遍历得到的序列是：

> 4 2 5 1 6 3 7

中序遍历递归代码如下：
~~~html
#include <stdio.h>
#include <string.h>
#define TElemType int
//构造结点的结构体
typedef struct BiTNode{
    TElemType data;//数据域
    struct BiTNode *lchild,*rchild;//左右孩子指针
}BiTNode,*BiTree;
//初始化树的函数
void CreateBiTree(BiTree *T){
    *T=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->data=1;
    (*T)->lchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->rchild=(BiTNode*)malloc(sizeof(BiTNode));
  
    (*T)->lchild->data=2;
    (*T)->lchild->lchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->lchild->rchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->lchild->rchild->data=5;
    (*T)->lchild->rchild->lchild=NULL;
    (*T)->lchild->rchild->rchild=NULL;
    (*T)->rchild->data=3;
    (*T)->rchild->lchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->rchild->lchild->data=6;
    (*T)->rchild->lchild->lchild=NULL;
    (*T)->rchild->lchild->rchild=NULL;
    (*T)->rchild->rchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->rchild->rchild->data=7;
    (*T)->rchild->rchild->lchild=NULL;
    (*T)->rchild->rchild->rchild=NULL;
    (*T)->lchild->lchild->data=4;
    (*T)->lchild->lchild->lchild=NULL;
    (*T)->lchild->lchild->rchild=NULL;
}
//模拟操作结点元素的函数，输出结点本身的数值
void displayElem(BiTNode* elem){
    printf("%d ",elem->data);
}
//中序遍历
void INOrderTraverse(BiTree T){
    if (T) {
        INOrderTraverse(T->lchild);//遍历左孩子
        displayElem(T);//调用操作结点数据的函数方法
        INOrderTraverse(T->rchild);//遍历右孩子
    }
    //如果结点为空，返回上一层
    return;
}
int main() {
    BiTree Tree;
    CreateBiTree(&Tree);
    printf("中序遍历算法: \n");
    INOrderTraverse(Tree);
}
~~~

中序遍历的非递归方式实现思想是：从根结点开始，遍历左孩子同时压栈，当遍历结束，说明当前遍历的结点没有左孩子，从栈中取出来调用操作函数，然后访问该结点的右孩子，继续以上重复性的操作。
除此之外，还有另一种实现思想：中序遍历过程中，只需将每个结点的左子树压栈即可，右子树不需要压栈。当结点的左子树遍历完成后，只需要以栈顶结点的右孩子为根结点，继续循环遍历即可。

~~~html
#include <stdio.h>
#include <string.h>
#define TElemType int
int top=-1;//top变量时刻表示栈顶元素所在位置
//构造结点的结构体
typedef struct BiTNode{
    TElemType data;//数据域
    struct BiTNode *lchild,*rchild;//左右孩子指针
}BiTNode,*BiTree;
//初始化树的函数
void CreateBiTree(BiTree *T){
    *T=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->data=1;
    (*T)->lchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->rchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->lchild->data=2;
    (*T)->lchild->lchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->lchild->rchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->lchild->rchild->data=5;
    (*T)->lchild->rchild->lchild=NULL;
    (*T)->lchild->rchild->rchild=NULL;
    (*T)->rchild->data=3;
    (*T)->rchild->lchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->rchild->lchild->data=6;
    (*T)->rchild->lchild->lchild=NULL;
    (*T)->rchild->lchild->rchild=NULL;
    (*T)->rchild->rchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->rchild->rchild->data=7;
    (*T)->rchild->rchild->lchild=NULL;
    (*T)->rchild->rchild->rchild=NULL;
    (*T)->lchild->lchild->data=4;
    (*T)->lchild->lchild->lchild=NULL;
    (*T)->lchild->lchild->rchild=NULL;
}
//前序和中序遍历使用的进栈函数
void push(BiTNode** a,BiTNode* elem){
    a[++top]=elem;
}
//弹栈函数
void pop( ){
    if (top==-1) {
        return ;
    }
    top--;
}
//模拟操作结点元素的函数，输出结点本身的数值
void displayElem(BiTNode* elem){
    printf("%d ",elem->data);
}
//拿到栈顶元素
BiTNode* getTop(BiTNode**a){
    return a[top];
}
//中序遍历非递归算法
void InOrderTraverse1(BiTree Tree){
    BiTNode* a[20];//定义一个顺序栈
    BiTNode * p;//临时指针
    push(a, Tree);//根结点进栈
    while (top!=-1) {//top!=-1说明栈内不为空，程序继续运行
        while ((p=getTop(a)) &&p){//取栈顶元素，且不能为NULL
            push(a, p->lchild);//将该结点的左孩子进栈，如果没有左孩子，NULL进栈
        }
        pop();//跳出循环，栈顶元素肯定为NULL，将NULL弹栈
        if (top!=-1) {
            p=getTop(a);//取栈顶元素
            pop();//栈顶元素弹栈
            displayElem(p);
            push(a, p->rchild);//将p指向的结点的右孩子进栈
        }
    }
}
//中序遍历实现的另一种方法
void InOrderTraverse2(BiTree Tree){
    BiTNode* a[20];//定义一个顺序栈
    BiTNode * p;//临时指针
    p=Tree;
    //当p为NULL或者栈为空时，表明树遍历完成
    while (p || top!=-1) {
        //如果p不为NULL，将其压栈并遍历其左子树
        if (p) {
            push(a, p);
            p=p->lchild;
        }
        //如果p==NULL，表明左子树遍历完成，需要遍历上一层结点的右子树
        else{
            p=getTop(a);
            pop();
            displayElem(p);
            p=p->rchild;
        }
    }
}
int main(){
    BiTree Tree;
    CreateBiTree(&Tree);
    printf("中序遍历算法1: \n");
    InOrderTraverse1(Tree);
    printf("\n中序遍历算法2: \n");
    InOrderTraverse2(Tree);
}
~~~

## 6.6 二叉树后序遍历(递归与非递归)

二叉树后序遍历的实现思想是：从根节点出发，依次遍历各节点的左右子树，直到当前节点左右子树遍历完成后，才访问该节点元素。

![img](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/09501WI4-0.png)

上图二叉树后序遍历的结果为：

> 4 5 2 6 7 3 1 

递归实现的代码为：
~~~html
#include <stdio.h>
#include <string.h>
#define TElemType int
//构造结点的结构体
typedef struct BiTNode{
    TElemType data;//数据域
    struct BiTNode *lchild,*rchild;//左右孩子指针
}BiTNode,*BiTree;
//初始化树的函数
void CreateBiTree(BiTree *T){
    *T=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->data=1;
    (*T)->lchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->rchild=(BiTNode*)malloc(sizeof(BiTNode));
  
    (*T)->lchild->data=2;
    (*T)->lchild->lchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->lchild->rchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->lchild->rchild->data=5;
    (*T)->lchild->rchild->lchild=NULL;
    (*T)->lchild->rchild->rchild=NULL;
    (*T)->rchild->data=3;
    (*T)->rchild->lchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->rchild->lchild->data=6;
    (*T)->rchild->lchild->lchild=NULL;
    (*T)->rchild->lchild->rchild=NULL;
    (*T)->rchild->rchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->rchild->rchild->data=7;
    (*T)->rchild->rchild->lchild=NULL;
    (*T)->rchild->rchild->rchild=NULL;
    (*T)->lchild->lchild->data=4;
    (*T)->lchild->lchild->lchild=NULL;
    (*T)->lchild->lchild->rchild=NULL;
}
//模拟操作结点元素的函数，输出结点本身的数值
void displayElem(BiTNode* elem){
    printf("%d ",elem->data);
}
//后序遍历
void PostOrderTraverse(BiTree T){
    if (T) {
        PostOrderTraverse(T->lchild);//遍历左孩子
        PostOrderTraverse(T->rchild);//遍历右孩子
        displayElem(T);//调用操作结点数据的函数方法
    }
    //如果结点为空，返回上一层
    return;
}
int main() {
    BiTree Tree;
    CreateBiTree(&Tree);
    printf("后序遍历: \n");
    PostOrderTraverse(Tree);
}
~~~

后序遍历是在遍历完当前结点的左右孩子之后，才调用操作函数，所以需要在操作结点进栈时，为每个结点配备一个标志位。当遍历该结点的左孩子时，设置当前结点的标志位为 0，进栈；当要遍历该结点的右孩子时，设置当前结点的标志位为 1，进栈。

这样，当遍历完成，该结点弹栈时，查看该结点的标志位的值：如果是 0，表示该结点的右孩子还没有遍历；反之如果是 1，说明该结点的左右孩子都遍历完成，可以调用操作函数。
非递归实现的代码为：

~~~html
#include <stdio.h>
#include <string.h>
#define TElemType int
int top=-1;//top变量时刻表示栈顶元素所在位置
//构造结点的结构体
typedef struct BiTNode{
    TElemType data;//数据域
    struct BiTNode *lchild,*rchild;//左右孩子指针
}BiTNode,*BiTree;
//初始化树的函数
void CreateBiTree(BiTree *T){
    *T=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->data=1;
    (*T)->lchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->rchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->lchild->data=2;
    (*T)->lchild->lchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->lchild->rchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->lchild->rchild->data=5;
    (*T)->lchild->rchild->lchild=NULL;
    (*T)->lchild->rchild->rchild=NULL;
    (*T)->rchild->data=3;
    (*T)->rchild->lchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->rchild->lchild->data=6;
    (*T)->rchild->lchild->lchild=NULL;
    (*T)->rchild->lchild->rchild=NULL;
    (*T)->rchild->rchild=(BiTNode*)malloc(sizeof(BiTNode));
    (*T)->rchild->rchild->data=7;
    (*T)->rchild->rchild->lchild=NULL;
    (*T)->rchild->rchild->rchild=NULL;
    (*T)->lchild->lchild->data=4;
    (*T)->lchild->lchild->lchild=NULL;
    (*T)->lchild->lchild->rchild=NULL;
}
//弹栈函数
void pop( ){
    if (top==-1) {
        return ;
    }
    top--;
}
//模拟操作结点元素的函数，输出结点本身的数值
void displayElem(BiTNode* elem){
    printf("%d ",elem->data);
}
//后序遍历非递归算法
typedef struct SNode{
    BiTree p;
    int tag;
}SNode;
//后序遍历使用的进栈函数
void postpush(SNode *a,SNode sdata){
    a[++top]=sdata;
}
//后序遍历函数
void PostOrderTraverse(BiTree Tree){
    SNode a[20];//定义一个顺序栈
    BiTNode * p;//临时指针
    int tag;
    SNode sdata;
    p=Tree;
    while (p||top!=-1) {
        while (p) {
            //为该结点入栈做准备
            sdata.p=p;
            sdata.tag=0;//由于遍历是左孩子，设置标志位为0
            postpush(a, sdata);//压栈
            p=p->lchild;//以该结点为根结点，遍历左孩子
        }
        sdata=a[top];//取栈顶元素
        pop();//栈顶元素弹栈
        p=sdata.p;
        tag=sdata.tag;
        //如果tag==0，说明该结点还没有遍历它的右孩子
        if (tag==0) {
            sdata.p=p;
            sdata.tag=1;
            postpush(a, sdata);//更改该结点的标志位，重新压栈
            p=p->rchild;//以该结点的右孩子为根结点，重复循环
        }
        //如果取出来的栈顶元素的tag==1，说明此结点左右子树都遍历完了，可以调用操作函数了
        else{
            displayElem(p);
            p=NULL;
        }
    }
}
int main(){
    BiTree Tree;
    CreateBiTree(&Tree);
    printf("后序遍历: \n");
    PostOrderTraverse(Tree);
}
~~~

## 6.7 二叉树层次遍历

层次遍历的具体思路是：通过使用**队列**的数据结构，从树的根结点开始，依次将其左孩子和右孩子入队。而后每次队列中一个结点出队，都将其左孩子和右孩子入队，直到树中所有结点都出队，出队结点的先后顺序就是层次遍历的最终结果。
![img](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/09515K014-0.png)

例如，层次遍历图 1 中的二叉树：

- 首先，根结点 1 入队；
- 根结点 1 出队，出队的同时，将左孩子 2 和右孩子 3 分别入队；
- 队头结点 2 出队，出队的同时，将结点 2 的左孩子 4 和右孩子 5 依次入队；
- 队头结点 3 出队，出队的同时，将结点 3 的左孩子 6 和右孩子 7 依次入队；
- 不断地循环，直至队列内为空。

~~~c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if(root != NULL) que.push(root);
        vector<vector<int>> result;
        while(! que.empty()){
            int size = que.size();
            vector<int> vec;
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
~~~

## 6.8 线索二叉树

==指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树（Threaded Binary Tree）==

### 6.8.1 线索二叉树的结点结构

如果在二叉树中想保存每个结点前趋和后继所在的位置信息，最直接的想法就是改变结点的结构，即添加两个指针域，分别指向该结点的前趋和后继。
每一棵二叉树上，很多结点都含有未使用的指向NULL的指针域。除了度为2的结点，度为 1 的结点，有一个空的指针域；叶子结点两个指针域都为NULL。
线索二叉树中，如果结点有左子树，则 lchild 指针域指向左孩子，否则 lchild 指针域指向该结点的直接前趋；同样，如果结点有右子树，则 rchild 指针域指向右孩子，否则 rchild 指针域指向该结点的直接后继。
为了避免指针域指向的结点的意义混淆，需要改变结点本身的结构，增加两个标志域，如下图所示。
![img](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/0951022B5-1.png)

LTag 和 RTag 为标志域。实际上就是两个布尔类型的变量：

- LTag 值为 0 时，表示 lchild 指针域指向的是该结点的左孩子；为 1 时，表示指向的是该结点的直接前趋结点；
- RTag 值为 0 时，表示 rchild 指针域指向的是该结点的右孩子；为 1 时，表示指向的是该结点的直接后继结点。

结点结构代码实现：
~~~~html
#define TElemType int //宏定义，结点中数据域的类型
//枚举，Link为0，Thread为1
typedef enum PointerTag{
	Link,
	Thread 
}PointerTag;
//结点结构构造
typedef struct BiThrNode{
	TElemType data;//数据域
	struct BiThrNode* lchild,*rchild;//左孩子，有孩子指针域
	PointerTag Ltag,Rtag;//标志域，枚举类型 
}BiThrNode,*BiThrTree; 
~~~~

### 6.8.2 对二叉树进行线索化

将二叉树转化为线索二叉树，实质上是在遍历二叉树的过程中，将二叉链表中的空指针改为指向直接前趋或者直接后继的线索。

> 线索化的过程即为在遍历的过程中修改空指针的过程

在遍历过程中，如果当前结点没有左孩子，需要将该结点的 lchild 指针指向遍历过程中的前一个结点，所以在遍历过程中，设置一个指针（名为 pre），时刻指向当前访问结点的前一个结点。

代码实现如下（中序遍历）：

~~~html
//中序对二叉树进行线索化
void InThreading(BiThrTree p){
	//如果当前结点存在
	if(p){
		Inthreading(p->lchild);//递归当前结点的左子树，进行线索化
		//如果当前结点没有左孩子，左标志位设为1，左指针域指向上一结点 pre
		if(!p->lchild){
			p->Ltag = Thread;
			p->lchild = pre;
		} 
		//如果 pre 没有右孩子，右标志位设为1，右指针域指向当前结点
		if(!pre->rchild){
			pre->Rtag = Thread;
			pre->rchild = p;
		} 
		pre = p;//线索化完左子树后，让pre指针指向当前结点
		InThreading(p->rchild);//递归右子树进行线索化 
	} 
} 
~~~

### 6.8.3 遍历二叉线索数

~~~html
//中序遍历线索二叉树
void InOrderThraverse_Thr(BiThrTree p)
{
    while(p)
    {
        //一直找左孩子，最后一个为中序序列中排第一的
        while(p->Ltag == Link){
            p = p->lchild;
        }
        printf("%c ", p->data);  //操作结点数据
        //当结点右标志位为1时，直接找到其后继结点
        while(p->Rtag == Thread && p->rchild !=NULL){
            p = p->rchild;
            printf("%c ", p->data);
        }
        //否则，按照中序遍历的规律，找其右子树中最左下的结点，也就是继续循环遍历
        p = p->rchild;
    }
}
~~~



# 7. 图



## 7.1 图的定义与术语总结

图按照有无方向分为==有向图==和==无向图==。有向图由顶点和==弧==构成，无向图由==顶点==和==边==构成。弧有==弧尾==和==弧头==之分。

图按照边或弧的多少分为==稀疏图==和==稠密图==。如果任意两个顶点之间都存在边叫==完全图==，有向的叫==有向完全图==。若无重复的边或顶点到自身的边则叫==简单图==。

图中顶点之间有==邻接点==、==依附==的概念。无向图顶点的边数叫做度，有向图顶点分为==入度==和==出度==。

图上的边或弧上带==权==则称为==网==。

图中顶点间存在==路径==，两顶点存在路径则说明是==连通的==，如果路径最终回到起始点则称为==环==，当中不重复叫==简单路径==。若任意两顶点都是连通的，则图就是==连通图==，有向则称==强连通图==。图中有子图，若子图极大连通则就是==连通分量==，有向的则称==强连通分量==。

无向图中连通且n个顶点n-1条边叫==生成树==。有向图中一顶点入度为0其余顶点入度为1的叫==有向树==。一个有向图由若干课有向树构==生成森林==。

## 7.2 图的存储结构

### 7.2.1 邻接矩阵

==图的邻接矩阵（Adjacency Matrix）存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。==

设图G有n个顶点，则邻接矩阵是一个n×n的方阵，定义为：
$$ arc[i] [j]=\left\{
\begin{aligned}
1& &\若(v~i~,v~j~)∈E或<v~i~,v~j~>∈E \\\
0& &\其他
\end{aligned}
\right.
$$

![image-20230326093834263](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230326093834263.png)

我们可以设置两个数组’顶点数组为vertex[4] = {v~0~,v~1~,v~2~,v~3~}，边数组arc[4] [4]为右上图这样的一个矩阵。对于矩阵的主对角线的值，即arc[0] [0]、arc[1] [1]、arc[2] [2]、arc[3] [3]，全为0是因为不存在顶点到自身的边，比如v~0~到v~0~。所以无向图的边数组是一个对称矩阵。

有了对称矩阵，我们就可以很容易地知道图中的信息。
（1）我们要判定任意两顶点是否有边无边就非常容易了。 
（2）我们要知道某个顶点的度，其实就是这个顶点v~i~在邻接矩阵中第 i 行（或第 i 列） 的元素之和。比如顶点v~i~的度就是l＋0＋1＋0＝2。
（3）求顶点v~i~的所有邻接点就是将矩阵中第i行元素扫描一遍，arc[i] [j]为1就是邻接点。

我们再看一个有向图样例，如左下图所示。
![image-20230326094936811](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230326094936811.png)

顶点数组为vertex[4] = {v~0~,v~1~,v~2~,v~3~}，弧数组arc[4] [4]为上图右图这样一个矩阵。主对角线上数值依然为0。但因为是有向图，所以此矩阵并不对称，比如由v~1~到v~0~有弧，得到arc[1] [0]=1，而v~0~到v~1~没有弧，因此arc[0] [1]=0。
有向图讲究入度和出度，顶点v~1~的入度为1，正好是第v~1~列各数之和。顶点v~1~的出度为2，即第v~1~行的各数之和。

判断顶点v~i~到v~j~是否存在弧，只需要查找矩阵中arc[i] [j]是否为1即可。要求v~i~的所有邻接点就是将矩阵第i行元素扫描一遍，查找arc[i] [j]为1的顶点。

在图的术语中，我们提到了网的概念，也就是每条边上带有权的图叫做网。那么这些权值就需要存下来，如何处理这个矩阵来适应这个需求呢？我们有办法。
![image-20230326100431009](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230326100431009.png)

这里w~ij~表示(v~i~,v~j~) 或<v~i~,v~j~>上的权值。∞表示一个计算机允许的、大于所有边上权值的值，也就是一个不可能的极限值。有同学会问，为什么不是0呢？原因在于权值w~ij~大多数情况下是正值，但个别时候可能就是0，甚至有可能是负值。因此必须要用一个不可能的值来代表不存在。如左下图就是一个有向网图，右下图就是它的邻接矩阵。
![image-20230326100940191](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230326100940191.png)

图的邻接矩阵存储的结构，代码如下：
~~~html
typedef char VertexType; //顶点类型应由用户定义
typedef int EdgeType; //边上的权值类型应由用户定义
#define MAXVEX 100 //最大顶点数，应由用户定义
#define INFINITY 65535 //用65535来代表
typedef struct
{
	VertexType vexs[MAXVEX]; //顶点表
	EdgeType arc[MAXVEX][MAXVEX]; //邻接矩阵，可看作边表
	int numNodes,numEdges; //图中当前的顶点数和边数 
}MGragh;
~~~

有了这个结构定义，我们构造一个图，其实就是给顶点表和边表输入数据的过程。我们来看看无向网图的创建代码。
~~~html
//建立无向网图的邻接矩阵表示
void CreateMGraph(MGraph *G)
{
	int i,j,k,w;
	printf("输入顶点数和边数：\n");
	scanf("%d,%d",&G->numNodes,&G->numEdges); //输入顶点数和边数
	for(i = 0; i < G->numNodes; i++)
		scanf(&G->vexs[i]);
	for(i = 0;i < G->numNodes; i++)
		for(j = 0;j < G->numNodes; j++)
			G->arc[i][j] = INFINITY; //邻接矩阵初始化
	for(k = 0;k < G->numEdges; k++) //读入numEdges条边，建立邻接矩阵 
	{
		printf("输入边(vi,vj)上的下标i,下标j和权w:\n");
		scanf("%d,%d,%d",&i,&j,&w); //输入边(vi,vj)上的权w
		G->arc[i][j] = w;
		G->arc[j][i] = G->arc[i][j]; //因为是无向图，矩阵对称 
	}		 
} 
~~~

==n个顶点和e条边的无向网图的创建，时间复杂度为O(n+n^2^+e)==

### 7.2.2 邻接表

我们在树中谈存储结构时，讲到了一种孩子表示法，将结点存入数组，并对结点的孩子进行链式存储，不管有多少孩子，也不会存在空间浪费问题。这个思路同样适用于图的存储。我们把这种==数组与链表相结合的存储方法称为邻接表（Adjacency List）==。

邻接表的处理方法如下：
（1）图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。另外，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息。
（2）图中每个顶点v~i~的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图为顶点v~i~的边表，有向图则称为顶点v~i~作为弧尾的出边表。

例如下图所示就是一个无向图的邻接表结构。
![image-20230326114810546](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230326114810546.png)

顶点表的各个结点由data和firstedge两个域表示，data是数据域，存储顶点的信息，firstedge是指针域，指向边表的第一个结点，即此顶点的第一个邻接点。边表结点由adjvex和next两个域组成。adjvex是邻接点域，存储某顶点的邻接点在顶点表中的下标，next则存储指向边表中下一个结点的指针。比如v~1~顶点与v~0~、v~2~互为邻接点，则在v~1~的边表中，adjvex分别为v~0~的0和v~2~的2。

若是有向图，邻接表结构是类似的，比如左下图的邻接表就是右下图。但要注意的是有向图由于有方向，我们是以顶点为弧尾来存储边表的，这样很容易就可以得到每个顶点的出度。

![image-20230326120758625](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230326120758625.png)

有时为了便于确定顶点的入度或以顶点为弧头的弧，我们可以建立==一个有向图的逆邻接表，即对每个顶点v~i~都建立一个链接为v~i~为弧头的表。如下图的逆邻接表所示。
![image-20230326121116447](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230326121116447.png)

对于带权值的网图，可以在边表结点定义中再增加一个weight的数据域，存储权值信息即可，如下图所示。
![image-20230326121237625](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230326121237625.png)

下面是关于结点定义的代码：
~~~html
typedef char VertexType; //顶点类型应由用户定义
typedef int EdgeType; //边上的权值类型应由用户定义

typedef struct EdgeNode //边表结点 
{
	int adjvex; //邻接点域，存储该顶点对应的下标
	EdgeType info; //用于存储权限，对于非网图可以不需要
	struct EdgeNode *next; //链域，指向下一个邻接点 
}EdgeNode;

typedef struct VertexNode
{
	VertexType data; //顶点域，存储顶点信息
	EdgeNode *firstedge; //边表头指针 
}VertexNode, AdjList[MAXVEX];//存储各链表头结点的数组

typedef struct
{
	AdjList adjList;//图中顶点的数组
	int numNodes,numEdges; //图中当前顶点数和边数 
}GraphAdjList;
~~~

无向图的邻接表的创建代码如下：
~~~html
//建立图的邻接表结构
void CreateALGraph(GraphAdjList *G)
{
	int i,j,k;
	EdgeNode *e;
	printf("输入顶点数和边数：\n");
	scanf("%d%d",&G->numNodes,&G->numEdges); //输入顶点数和边数
	for(i = 0; i < G->numNodes; i++) //读入顶点信息，建立顶点表 
	{
		scanf(&G->adjList[i].data); //输入顶点信息
		G->adjList[i].firstedge=NULL; //将边表置为空表 
	} 
	
	for(k = 0;k < G->numEdges; k++) //建立边表 
	{
		printf("输入边(vi,vj)上的顶点序号：\n");
		scanf("%d%d",&i,&j); //输入边(vi,vj)上的顶点序号
	    e=(EdgeNode *)malloc(sizeof(EdgeNode)); //向内存申请空间，生成边表结点
		e->adjvex = j; //邻接序号为j
		e->next = G->adjList[i].firstedge; //将e的指针指向当前顶点指向的结点
		G->adjList[i].firstedge = e; //将当前顶点的指针指向e
		e=(EdgeNode *)malloc(sizeof(EdgeNode)); //向内存申请空间，生成边表结点
		e->adjvex = i; //邻接序号为i
		e->next = G->adjList[j].firstedge; //将e的指针指向当前顶点指向的结点
		G->adjList[j].firstedge = e; //将当前顶点的指针指向e  
	}
} 
~~~

我们应用到了在单链表创建中讲到的头插法，对于无向图，一条边都是对应两个顶点，所以在循环中，一次就针对i和j分别进行了插入。本算法的时间复杂度，对于n个顶点e条边来说，很容易得出是O(n+e)。

### 7.2.3 十字链表

对于有向图来说，邻接表是有缺陷的。关心了出度问题，想了解入度就必须要遍历整个图才知道，反之，逆邻接表解决了入度却不了解出度的情况。为了把它们整合在一起，就需要图的另一种链式存储结构，十字链表（Orthogonal List）。

==十字链表实质上就是为每个顶点建立两个链表，分别存储以该顶点为弧头的所有顶点和以该顶点为弧尾的所有顶点==

我们重新定义顶点表结点结构如下表所示。

| data | firstin | firstout |
| ---- | ------- | -------- |

其中，firstin表示入边表头指针，指向该顶点的入边表中第一个结点；firstout表示出边表头指针，指向该顶点的出边表中的第一个结点。

重新定义的边表结点结构如下表所示。

| tailvex | headvex | headlink | taillink |
| ------- | ------- | -------- | -------- |

其中，tailvex是指弧起点在顶点表中的下标；headvex是指弧终点在顶点表中的下标；headlink是指入边表指针域，指向终点相同的下一条边；taillink是指边表指针域，指向起点相同的下一条边。如果是网，还可以再增加一个weight域来存储权值。

比如说，用十字链表存储图（a）中的有向图，存储状态如图（b）所示：

![image-20230326162914207](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230326162914207.png)

拿图 3 中的顶点 V1 来说，通过构建好的十字链表得知，以该顶点为弧头的顶点只有存储在数组中第 3 位置的 V4（因此该顶点的入度为 1），而以该顶点为弧尾的顶点有两个，分别为存储数组第 1 位置的 V2 和第 2 位置的 V3（因此该顶点的出度为 2）。

对于图 3 各个链表中节点来说，由于表示的都是该顶点的出度或者入度，因此没有先后次序之分。

图3中十字链表的构建过程转化为C语言代码为：
~~~html
#define MAX_VERTEX_NUM 20
#define InfoType int //图中弧包含信息的数据类型
#define VertexType int
typedef struct ArcBox{
	int tailvex,headvex; //弧尾、弧头对应顶点在数组中的位置下标
	struct ArcBox *hlik,*tlink; //分别指向弧头相同和弧尾相同的下一个弧
	InfoType *info; //存储弧相关信息的指针 
}ArcBox;
typedef struct VexNode{
	VertexType data; //顶点的数据域
	ArcBox *firstin,*firstout; //指向以该顶点为弧头和弧尾的链表首个结点 
}VexNode;
typedef struct{
	VexNode xlist[MAX_VERTEX_NUM]; //存储顶带你的一维数组
	int vexnum,arcnum; //记录图的顶点数和弧数 
}OLGraph;
int LocateVex(OLGraph * G,VertexType v){
	int i = 0;
	//遍历一维数组，找到变量v
	for(;i < G->vexnum; i++){
		if(G->xlist[i].data==v)
		{
			break;
		}
    }
    //如果找不到，输出提示语句，返回-1
	if(i > G->vexnum){
		printf("no such vertex.\n");
		return -1;
	} 
	return -1;
} 
//构建十字链表函数
void CreateDG(OLGraph *G){
	//输入有向图的顶点数和弧数
	scanf("%d%d",&(G->vexnum),&(G->arcnum));
	//使用一维数组存储顶点数据，初始化指针域为NULL 
	for(int i = 0; i < G->vexnum; i++){
		scanf("%d",&(G->xlist[i].data));
		G->xlist[i].firstin = NULL;
		G->xlist[i].firstout = NULL;
	}
	//构建十字链表
	for(int k = 0;k < G->arcnum; k++){
		int v1,v2;
		scanf("%d%d",&v1,&v2);
		//确定v1、v2在数组中的位置下标
		int i = LocateVex(G,v1);
		int j = LocateVex(G,v2);
		//建立弧的结点
		ArcBox * p =(ArcBox*)malloc(sizeof(ArcBox));
		p->tailvex = i;
		p->headvex = j;
		//采用头插法插入新的p结点
		p->hilk = G->xlist[j].firstin;
		p->tlink = G->xlist[i].firstout;
		G->xlist[j].firstin = G->xlist[i].firstout = p; 
	}
} 
~~~

### 7.2.4 邻接多重表

我们也可以仿照十字链表的方式，对边表结点的结构进行一些改造，得到邻接多重表结构。

| ivex | ilink | jvex | jlink |
| ---- | ----- | ---- | ----- |

==ivex和jvex是与某条边依附的两个顶点在顶点表中的下标；ilink指向依附顶点ivex的下一条边；jlink指向依附顶点jvex的下一条边。这就是邻接多重表结构。==

综合以上信息，如果我们想使用邻接多重表存储图 3a) 中的无向图，则与之对应的邻接多重表如图 3b) 所示：

![无向图及其对应的邻接多重表](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/100P54393-2.gif)

从图 3 中，可直接找到与各顶点有直接关联的其他顶点。比如说，与顶点 V1 有关联的顶点为存储在数组下标 1 处的 V2 和数组下标 3 处的 V4，而与顶点 V2 有关联的顶点有 3 个，分别是 V1、V3 和 V5。

图 3 中邻接多重表的整体结构转化为 C 语言代码如下所示：

~~~html
#define MAX_VERTEX_NUM 20                   //图中顶点的最大个数
#define InfoType int                        //边含有的信息域的数据类型
#define VertexType int                      //图顶点的数据类型
typedef enum {unvisited,visited}VisitIf;    //边标志域
typedef struct EBox{
    VisitIf mark;                           //标志域
    int ivex,jvex;                          //边两边顶点在数组中的位置下标
    struct EBox * ilink,*jlink;             //分别指向与ivex、jvex相关的下一个边
    InfoType *info;                         //边包含的其它的信息域的指针
}EBox;
typedef struct VexBox{
    VertexType data;                        //顶点数据域
    EBox * firstedge;                       //顶点相关的第一条边的指针域
}VexBox;
typedef struct {
    VexBox adjmulist[MAX_VERTEX_NUM];//存储图中顶点的数组
    int vexnum,degenum;//记录途中顶点个数和边个数的变量
}AMLGraph;
~~~

## 7.3 图的遍历

==从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历（Traversing Graph）==

![无向图](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/10094U249-0.png)

### 7.3.1 深度优先遍历

==深度优先遍历（Depth First Search），也有称为深度优先搜素，简称为DFS==

==它从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到==。对于非连通图，只需要对它的连通分量分别进行深度优先遍历，即在先前一个顶点进行一次深度优先遍历后，==若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。==

> V1 -> V2 -> V4 -> V8 -> V5 -> V3 -> V6 -> V7

~~~html
#include <stdio.h>
#define MAX_VERtEX_NUM 20                   //顶点的最大个数
#define VRType int                          //表示顶点之间的关系的变量类型
#define InfoType char                       //存储弧或者边额外信息的指针变量类型
#define VertexType int                      //图中顶点的数据类型
typedef enum{false,true}bool;               //定义bool型常量
bool visited[MAX_VERtEX_NUM];               //设置全局数组，记录标记顶点是否被访问过
typedef struct {
    VRType adj;                             //对于无权图，用 1 或 0 表示是否相邻；对于带权图，直接为权值。
    InfoType * info;                        //弧或边额外含有的信息指针
}ArcCell,AdjMatrix[MAX_VERtEX_NUM][MAX_VERtEX_NUM];
typedef struct {
    VertexType vexs[MAX_VERtEX_NUM];        //存储图中顶点数据
    AdjMatrix arcs;                         //二维数组，记录顶点之间的关系
    int vexnum,arcnum;                      //记录图的顶点数和弧（边）数
}MGraph;
//根据顶点本身数据，判断出顶点在二维数组中的位置
int LocateVex(MGraph * G,VertexType v){
    int i=0;
    //遍历一维数组，找到变量v
    for (; i<G->vexnum; i++) {
        if (G->vexs[i]==v) {
            break;
        }
    }
    //如果找不到，输出提示语句，返回-1
    if (i>G->vexnum) {
        printf("no such vertex.\n");
        return -1;
    }
    return i;
}
//构造无向图
void CreateDN(MGraph *G){
    scanf("%d,%d",&(G->vexnum),&(G->arcnum));
    for (int i=0; i<G->vexnum; i++) {
        scanf("%d",&(G->vexs[i]));
    }
    for (int i=0; i<G->vexnum; i++) {
        for (int j=0; j<G->vexnum; j++) {
            G->arcs[i][j].adj=0;
            G->arcs[i][j].info=NULL;
        }
    }
    for (int i=0; i<G->arcnum; i++) {
        int v1,v2;
        scanf("%d,%d",&v1,&v2);
        int n=LocateVex(G, v1);
        int m=LocateVex(G, v2);
        if (m==-1 ||n==-1) {
            printf("no this vertex\n");
            return;
        }
        G->arcs[n][m].adj=1;
        G->arcs[m][n].adj=1;//无向图的二阶矩阵沿主对角线对称
    }
}
int FirstAdjVex(MGraph G,int v)
{
    //查找与数组下标为v的顶点之间有边的顶点，返回它在数组中的下标
    for(int i = 0; i<G.vexnum; i++){
        if( G.arcs[v][i].adj ){
            return i;
        }
    }
    return -1;
}
int NextAdjVex(MGraph G,int v,int w)
{
    //从前一个访问位置w的下一个位置开始，查找之间有边的顶点
    for(int i = w+1; i<G.vexnum; i++){
        if(G.arcs[v][i].adj){
            return i;
        }
    }
    return -1;
}
void visitVex(MGraph G, int v){
    printf("%d ",G.vexs[v]);
}
void DFS(MGraph G,int v){
    visited[v] = true;//标记为true
    visitVex( G,  v); //访问第v 个顶点
    //从该顶点的第一个边开始，一直到最后一个边，对处于边另一端的顶点调用DFS函数
    for(int w = FirstAdjVex(G,v); w>=0; w = NextAdjVex(G,v,w)){
        //如果该顶点的标记位false，证明未被访问，调用深度优先搜索函数
        if(!visited[w]){
            DFS(G,w);
        }
    }
}
//深度优先搜索
void DFSTraverse(MGraph G){//
    int v;
    //将用做标记的visit数组初始化为false
    for( v = 0; v < G.vexnum; ++v){
        visited[v] = false;
    }
    //对于每个标记为false的顶点调用深度优先搜索函数
    for( v = 0; v < G.vexnum; v++){
        //如果该顶点的标记位为false，则调用深度优先搜索函数
        if(!visited[v]){
            DFS( G, v);
        }
    }
}
int main() {
    MGraph G;//建立一个图的变量
    CreateDN(&G);//初始化图
    DFSTraverse(G);//深度优先搜索图
    return 0;
}
~~~

### 7.3.2 广度优先遍历

==广度优先搜索（Breadth First Search），又称为广度优先搜索，简称BFS==

广度优先搜索类似于树的层次遍历。从图中的某一顶点出发，遍历每一个顶点时，依次遍历其所有的邻接点，然后再从这些邻接点出发，同样依次访问它们的邻接点。按照此过程，直到图中所有被访问过的顶点的邻接点都被访问到。

最后还需要做的操作就是查看图中是否存在尚未被访问的顶点，若有，则以该顶点为起始点，重复上述遍历的过程。

> V1 -> V2 -> v3 -> V4 -> V5 -> V6 -> V7 -> V8

实现代码如下：
~~~html
#include <stdio.h>
#include <stdlib.h>
#define MAX_VERtEX_NUM 20                   //顶点的最大个数
#define VRType int                          //表示顶点之间的关系的变量类型
#define InfoType char                       //存储弧或者边额外信息的指针变量类型
#define VertexType int                      //图中顶点的数据类型
typedef enum{false,true}bool;               //定义bool型常量
bool visited[MAX_VERtEX_NUM];               //设置全局数组，记录标记顶点是否被访问过
typedef struct Queue{
    VertexType data;
    struct Queue * next;
}Queue;
typedef struct {
    VRType adj;                             //对于无权图，用 1 或 0 表示是否相邻；对于带权图，直接为权值。
    InfoType * info;                        //弧或边额外含有的信息指针
}ArcCell,AdjMatrix[MAX_VERtEX_NUM][MAX_VERtEX_NUM];
typedef struct {
    VertexType vexs[MAX_VERtEX_NUM];        //存储图中顶点数据
    AdjMatrix arcs;                         //二维数组，记录顶点之间的关系
    int vexnum,arcnum;                      //记录图的顶点数和弧（边）数
}MGraph;
//根据顶点本身数据，判断出顶点在二维数组中的位置
int LocateVex(MGraph * G,VertexType v){
    int i=0;
    //遍历一维数组，找到变量v
    for (; i<G->vexnum; i++) {
        if (G->vexs[i]==v) {
            break;
        }
    }
    //如果找不到，输出提示语句，返回-1
    if (i>G->vexnum) {
        printf("no such vertex.\n");
        return -1;
    }
    return i;
}
//构造无向图
void CreateDN(MGraph *G){
    scanf("%d,%d",&(G->vexnum),&(G->arcnum));
    for (int i=0; i<G->vexnum; i++) {
        scanf("%d",&(G->vexs[i]));
    }
    for (int i=0; i<G->vexnum; i++) {
        for (int j=0; j<G->vexnum; j++) {
            G->arcs[i][j].adj=0;
            G->arcs[i][j].info=NULL;
        }
    }
    for (int i=0; i<G->arcnum; i++) {
        int v1,v2;
        scanf("%d,%d",&v1,&v2);
        int n=LocateVex(G, v1);
        int m=LocateVex(G, v2);
        if (m==-1 ||n==-1) {
            printf("no this vertex\n");
            return;
        }
        G->arcs[n][m].adj=1;
        G->arcs[m][n].adj=1;//无向图的二阶矩阵沿主对角线对称
    }
}
int FirstAdjVex(MGraph G,int v)
{
    //查找与数组下标为v的顶点之间有边的顶点，返回它在数组中的下标
    for(int i = 0; i<G.vexnum; i++){
        if( G.arcs[v][i].adj ){
            return i;
        }
    }
    return -1;
}
int NextAdjVex(MGraph G,int v,int w)
{
    //从前一个访问位置w的下一个位置开始，查找之间有边的顶点
    for(int i = w+1; i<G.vexnum; i++){
        if(G.arcs[v][i].adj){
            return i;
        }
    }
    return -1;
}
//操作顶点的函数
void visitVex(MGraph G, int v){
    printf("%d ",G.vexs[v]);
}
//初始化队列
void InitQueue(Queue ** Q){
    (*Q)=(Queue*)malloc(sizeof(Queue));
    (*Q)->next=NULL;
}
//顶点元素v进队列
void EnQueue(Queue **Q,VertexType v){
    Queue * element=(Queue*)malloc(sizeof(Queue));
    element->data=v;
    element->next = NULL;
    Queue * temp=(*Q);
    while (temp->next!=NULL) {
        temp=temp->next;
    }
    temp->next=element;
}
//队头元素出队列
void DeQueue(Queue **Q,int *u){
    (*u)=(*Q)->next->data;
    (*Q)->next=(*Q)->next->next;
}
//判断队列是否为空
bool QueueEmpty(Queue *Q){
    if (Q->next==NULL) {
        return true;
    }
    return false;
}
//广度优先搜索
void BFSTraverse(MGraph G){//
    int v;
    //将用做标记的visit数组初始化为false
    for( v = 0; v < G.vexnum; ++v){
        visited[v] = false;
    }
    //对于每个标记为false的顶点调用深度优先搜索函数
    Queue * Q;
    InitQueue(&Q);
    for( v = 0; v < G.vexnum; v++){
        if(!visited[v]){
            visited[v]=true;
            visitVex(G, v);
            EnQueue(&Q, G.vexs[v]);
            while (!QueueEmpty(Q)) {
                int u;
                DeQueue(&Q, &u);
                u=LocateVex(&G, u);
                for (int w=FirstAdjVex(G, u); w>=0; w=NextAdjVex(G, u, w)) {
                    if (!visited[w]) {
                        visited[w]=true;
                        visitVex(G, w);
                        EnQueue(&Q, G.vexs[w]);
                    }
                }
            }
        }
    }
}
int main() {
    MGraph G;//建立一个图的变量
    CreateDN(&G);//初始化图
    BFSTraverse(G);//广度优先搜索图
    return 0;
}
~~~

## 7.4 最小生成树

==我们把构造连通网的最小代价生成树称为最小生成树（Minimum Cost Spanning Tree）==

### 7.4.1 普里姆（Prim）算法

普利姆算法代码如下，左侧数字为行号。其中INFINITY为权值最大值，不妨是65535，MAXVEX为顶点个数最大值，此处大于等于9即可。现在假设我们自己就是计算机，在调用MiniSpanTree_Prim()函数，输入上述的邻接矩阵后，看看它是如何运行并打印出最小生成树的。
~~~html
//Prim算法生成最小生成树
void MiniSpanTree_Prim(MGraph G)
{
	int min,i,j,k; 
	int adjvex[MAXVEX];//保存相关顶点间边的权值点下标
	int lowcost[MAXVEX];//保存相关顶点间边的权值
	lowcost[0] = 0;//初始化第一个权值为0，即v0加入生成树
	adjvex[0] = 0;//初始化第一个顶点下标为0
	for(i = 1; i < G.numVertexes; i++)//循环除下标为0外的全部顶点 
	{
		lowcost[i] = G.arc[0][i];//将v0顶点与之有边的权值存入数组
		adjvex[i] = 0;//初始化都为v0的下标 
	}
	for(i = 1;i < G.numVertexes; i++)
	{
		min = INFINITY;//初始化最小权值为∞，可以是较大数字如65535等
		j = 1;k = 0;
		while(j < G.numVertexes) //循环全部顶点
		{
			if(lowcost[j] != 0 && lowcost[j] < min)
			{//如果权值不为0且权值小于min 
				min = lowcost[j];//则让当前权值成为最小值 
				k = j;//将当前最小值的下标存入k 
			}
			j++;
		} 
		printf("(%d,%d)\n",adjvex[k],k) //打印当前顶点边中权值最小的边
		lowcost[k] = 0;//将当前顶点权值设置为0，此顶点已完成任务
		for(j = 1; j < G.numVertexes; j++)//循环所有顶点 
		{ //如果下标为k的顶点的各边权值小于此前这些顶点未被加入生成树的权值 
			if(lowcost[j] != 0 && G.arc[k][j] < lowcost[j])
			{
				lowcost[j] = G.arc[k][j]; //将较小的权值存入lowcost相应位置
				adjvex[j] = k;//将下标为k的顶点存入adjvex 
			}
		} 
	}  
}
~~~

![image-20230406160421761](E:\Typora笔记\数据结构.assets\image-20230406160421761.png)

（1）程序开始运行，我们在第5行和第6行，创建了两个一维数组lowcost和adjvex，长度都为顶点个数9.
（2）第7行和第8行我们分别给这两个数组的第一个下标赋值为0，adjvex[0]=0其实意思是我们现在从顶点v~0~开始（事实上，最小生成树从哪个顶点开始计算都无所谓，我们假定从v~0~开始），lowcost[0]=0就表示v~0~已经被纳入到最小生成树中，之后凡是lowcost数组中的值被设置为0就是表示此下标的顶点被纳入最小生成树。
（3）第9~13行表示我们读取上图邻接矩阵的第一行数据。将数值赋值给lowcost数组，所以此时lowcost数组值为{0,10,65535,65535,65535,11,65535,65535,65535}，而adjvex则全部为0。此时我们已经完成整个初始化的工作，准备开始生成。
（4）第14~37行，整个循环过程就是构造最小生成树的过程。
（5）第16行和第17行，将min设置为了一个极大值65535，它的目的是为了之后找到一定范围内的最小权值。j用来做顶点下标循环的变量，k用来存储最小权值的定点下标。
（6）第18~26行，循环中不断修改min为当前lowcost数组中最小值，并用k保留此最小值的顶点下标。经过循环后，min=10，k=1。注意19行if判断的lowcost[j] != 0表示已经是生成树的顶点不参与最小权值的查找。
（7）第27行，因k=1，adjvex[1]=0，所以打印结果为（0，1），表示v~0~至v~1~边为最小生成树的第一条边。
（8）第28行，此时因k=1我们将lowcast[k]=0就是说顶点v~1~纳入到最小生成树中。此时lowcost数组值为{0,0,65535,65535,65535,11,65535,65535,65535}
（9）第29~36行，j 循环由1至8，因k=1，查找邻接矩阵的第v~1~行的各个权值，与lowcost的对应值比较，若更小则修改lowcost值，并将k值存入adjvex数组中。因第v~1~行有18、16、12均比65535小，所以最终lowcost数组的值为{0,0,18,65535,65535,11,16,65535,12}。adjvex数组的值为{0,0,1,0,0,0,1,0,1}。这里第30行if判断的lowcost[j]!=0也说明v~0~和v~1~已经是生成树的顶点不参与最小权值的比对了。
（10）再次循环，由第16行到第27行，此时min=11，k=5，adjvex[5]=0。因此打印结构为(0,5)。表示v~0~至v~5~边为最小生成树的第二条边。
（11）接下来执行到第37行，lowcost数组的值为{0,0,18,65535,26,0,16,65535,12}。adjvex数组的值为{0,0,1,0,5,0,1,0,1}。
（12）通过不断地转换，构造过程如下图所示。
<img src="E:\Typora笔记\数据结构.assets\image-20230406164152648.png" alt="image-20230406164152648" style="zoom: 67%;" />

下面是普利姆算法的实现定义：
假设N={V,{E}}是连通网，TE是N上最小生成树中边的集合。算法从U={u~0~}(u~0~∈V)，TE={ }开始。重复执行下列操作：在所有u∈U，v∈V-U的边(u,v)∈E中找到一条代价最小的边(u~0~,v~0~)并入集合TE，同时v~0~并入U，直至U=V为止。此时TE中必有n-1条边，则T=(V,{TE})为N的最小生成树。
由算法代码中的循环嵌套可得此算法的时间复杂度为O(n^2^)。

### 7.4.2 克鲁斯卡尔(Kruskal)算法

我们直接可以就边为目标去构建，因为权值是在边上，直接去找最小权值的边来构建生成树也是很自然的想法，只不过构建时要考虑是否会形成环路而已。此时我们就用到了图的存储结构中的边集数组结构。以下是edge边集数组结构的定义代码：
~~~html
//对边集数组Edge结构的定义
typedef struct{
	int begin;
	int end;
	int weight;
}Edge;
~~~

我们将同样的图的邻接矩阵通过程序转化为右下图的边集数组，并且对它们按权值从小到大排序。
<img src="E:\Typora笔记\数据结构.assets\image-20230416141057951.png" alt="image-20230416141057951" style="zoom:50%;" />

|           | begin | end  | weight |
| --------- | ----- | ---- | ------ |
| Edges[0]  | 4     | 7    | 7      |
| Edges[1]  | 2     | 8    | 8      |
| Edges[2]  | 0     | 1    | 10     |
| Edges[3]  | 0     | 5    | 11     |
| Edges[4]  | 1     | 8    | 12     |
| Edges[5]  | 3     | 7    | 16     |
| Edges[6]  | 1     | 6    | 16     |
| Edges[7]  | 5     | 6    | 17     |
| Edges[8]  | 1     | 2    | 18     |
| Edges[9]  | 6     | 7    | 19     |
| Edges[10] | 3     | 4    | 20     |
| Edges[11] | 3     | 8    | 21     |
| Edges[12] | 2     | 3    | 22     |
| Edges[13] | 3     | 6    | 24     |
| Edges[14] | 4     | 5    | 26     |

克鲁斯卡尔算法的思想就是站在了上帝视角。先把权值最短的边一个个挑出来。
MAXEDGE为边数量的极大值，此处大于等于15即可，MAXVEX为顶点个数最大值，此处大于等于9即可。实现代码如下：

~~~html
//Kruskal算法生成最小生成树
void MiniSpanTree_Kruskal(MGraph G)
{
	int i,n,m;
	Edge edges[MAXEDGE];//定义边集数组，edge的结构为begin，end，weight均为整型
	int parent[MAXVEX];//定义一数组用来判断边与边是否形成环路 
	
	//此处省略将邻接矩阵G转化为边集数组edges并按权由小到大排序的代码
	
	for(i = 0;i < G.numVertexes; i++)
		parent[i] = 0;//初始化数组值为0
	for(i = 0;i < G.numedges; i++) //循环每一条边
	{
		n = Find(parent,edges[i].begin);
		m = Find(parent,edges[i].end);
		if(n != m) //假如n与m不等，说明此边没有与现有的生成树形成环路
		{//将此边的结尾顶点放入下标为起点的parent中。表示此顶点已经在生成树集合中 
			parent[n] = m;
			printf("(%d,%d) %d\n",edges[i].begin,
			    edges[i].end,edges[i].weight);
		} 
	}	 
} 

//查找连线顶点尾部的下标
int Find(int *parent,int f)
{
	while(parent[f] > 0)
	{
		f = parent[f];
	}
	return f;
} 
~~~

## 7.5 最短路径

### 7.5.1 Floyd-Warshall

算法核心代码如下：
~~~html
for(k = 1;k < n; k++)
{
	for(i = 1;i < n; i++)
	{
		for(j = 1;j < n; j++)
		{
			if(e[i][j] > e[i][k] + e[k][j])
			{
				e[i][j] = e[i][k] + e[k][j];
			}
		}
	}
}
~~~

这段代码的基本思想就是：最开始只允许经过1号顶点进行中转，接下来只允许经过1号和2号顶点进行中转······允许经过1~n号所有顶点进行中转，求任意两点之间的最短路程。用一句话概括就是：从i号顶点到j号顶点只经过前k号点的最短路程，其实这是一种“动态规划”的思想。
~~~html
#include<stdio.h>
int main(){
	int e[10][10],k,i,j,n,m,t1,t2,t3;
	int inf = 99999999;//用inf(infinity的缩写)存储一个我们认为的正无穷值
	//读入n和m，n表示顶点个数，m表示边的条数
	scanf("%d %d",&n,&m);
	
	//初始化
	for(i = 1;i <= n; i++)
		for(j = 1;j <= n; j++)
			if(i == j) e[i][j] = 0;
			else e[i][j] = inf;
	//读入边
	for(i = 1;i <= m; i++)
	{
		scanf("%d %d %d",&t1,&t2,&t3);
		e[t1][t2] = t3;
	}
	
	for(k = 1;k <= n; k++)
		for(i = 1;i <= n; i++)
			for(j = 1;j <= n; j++)
				if(e[i][j] > e[i][k] + e[k][j])
					e[i][j] = e[i][k] + e[k][j]; 
	
	for(i = 1;i <= n; i++)
	{
		for(j = 1;j <= n; j++)
		{
			printf("%10d",e[i][j]);
		}
		printf("\n");
	}		
	return 0;
}
~~~

### 7.5.2 Dijkstra

算法的基本思想是：每次找到离源点最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。基本步骤如下：

1. 将所有的顶点分为两部分：已知最短路程的顶点集合P和未知最短路径的顶点集合Q。最开始，已知最短路径的顶点集合P中只有源点一个顶点。我们这里用一个 book 数组来记录哪些点在集合 P 中。例如对于某个顶点i，如果book[i]为1则表示这个顶点在集合P中，如果book[i]为0则表示这个顶点在集合Q中。
2. 设置源点s到自己的最短路径为0即dis[s]=0。若存在有源点能直接到达的顶点i，则把dis[i]设为e[s] [i]。同时把所有其他（源点不能直接到达的）顶点的最短路径设为∞。
3. 在集合Q的所有顶点中选择一个离源点s最近的顶点u（即dis[u]最小）加入到集合P。并考察所有以点u为起点的边，对每一条边进行松弛操作。
4. 重复第3步，如果集合Q为空，算法结束。最终 dis 数组中的值就是源点到所有顶点的最短路径。

完整的 Dijkstra 算法代码如下：
~~~html
#include<stdio.h>
int main()
{
	int e[10][10],dis[10],book[10],i,j,n,m,t1,t2,t3,u,v,min;
	int inf = 999999999; //用inf(infinity的缩写)存储一个我们认为的正无穷值
	//读入n和m，n表示顶点个数，m表示边的条数
	scanf("%d%d",&n,&m);
	//初始化
	for(i = 1;i <= n; i++)
		for(j = 1;j <= n; j++)
			if(i == j) e[i][j] = 0;
			else e[i][j] = inf;
	//读入边
	for(i = 1;i <= m; i++)
	{
		scanf("%d %d %d",&t1,&t2,&t3);
		e[t1][t2] = t3;
	}		
	
	//初始化dis数组，这里是1号顶点到其余各个顶点的初始路程
	for(i = 1;i <= n; i++)
		dis[i] = e[1][i];
	//book数组初始化	
	for(i = 1;i <= n; i++)
		book[i] = 0;
	book[1] = 1;	
	//Dijkstra算法核心语句
	for(i = 1;i <= n-1; i++)
	{
		//找到离1号顶点最近的顶点
		min = inf;
		for(j = 1;j <= n; j++)
		{
			if(book[j] == 0 && dis[j] < min)
			{
				min = dis[j];
				u = j;
			}
		}
		book[u] = 1;
		for(v = 1;v <= n; v++)
		{
			if(e[u][v] < inf)
			{
				if(dis[v] > dis[u] + e[u][v])
					dis[v] = dis[u] + e[u][v];
			}
		} 
	}
	
	//输出最终结果
	for(i = 1;i <= n; i++)
		printf("%d ",dis[i]);
	
	getchar();
	getchar();
	return 0;	
}
~~~

